{
    "docs": [
        {
            "location": "/", 
            "text": "This course will cover basic concepts and design trade-offs related to\nprogramming languages. The first half of the course focuses on functions,\ntypes, scope, storage management, exceptions, and continuations. The second\nhalf covers object-oriented features and concurrency. We will conclude with a\nfew special-topics in programming languages. The class also has a number of\nsmall labs where students get to implement some of the language features\ndiscussed in class.\n\n\n\n\nSection ID:\n 927504\n\n\nLectures:\n Tuesday and Thursday, 6:30-7:50PM in CENTR 115\n\n\nSection:\n Fridays, 5:00-5:50PM in CENTR 119\n\n\nStaff email:\n \n\n\nPiazza:\n \nhttps://piazza.com/ucsd/winter2018/cse130\n\n\nGradescope code:\n MV8JVW\n\n\n\n\nTextbook\n\n\nWe will occasionally be following John Mitchell's \nConcepts In Programming\nLanguages\n textbook and assigning reading from this book and various other\nonline resources and papers. Some of the book chapters have been revised, we\nwill be handing out PDFs of these chapters. Cheaper renting options for the book\nseem to be available online (e.g., on \nAmazon\n).\n\n\nIf you are serious about programming languages Benjamin Pierce's \nTypes and Programming\nLanguages\n is a must.\n\n\nCourse Staff\n\n\n\n\nInstructor:\n \nDeian Stefan\n\n\nTAs:\n Abdulrahman Alkhelaifi, Nadah Feteih, Purag Moumdjian, Kaiser Pister, and Sanjeev T Reddy", 
            "title": "About"
        }, 
        {
            "location": "/#textbook", 
            "text": "We will occasionally be following John Mitchell's  Concepts In Programming\nLanguages  textbook and assigning reading from this book and various other\nonline resources and papers. Some of the book chapters have been revised, we\nwill be handing out PDFs of these chapters. Cheaper renting options for the book\nseem to be available online (e.g., on  Amazon ).  If you are serious about programming languages Benjamin Pierce's  Types and Programming\nLanguages  is a must.", 
            "title": "Textbook"
        }, 
        {
            "location": "/#course-staff", 
            "text": "Instructor:   Deian Stefan  TAs:  Abdulrahman Alkhelaifi, Nadah Feteih, Purag Moumdjian, Kaiser Pister, and Sanjeev T Reddy", 
            "title": "Course Staff"
        }, 
        {
            "location": "/syllabus/", 
            "text": "Week of \n\n\nTuesday\n\n\nThursday\n\n\nFriday (section)\n\n\n\n\n\n\n\n\n\n\nJan 09 \n Jan 11\n\n\nJavaScript and high-order functions\n\n\nJavaScript and high-order functions (cont)\n\n\n\n\n\n\n\n\nJan 16 \n Jan 18\n\n\nLambda calculus\n\n\nLambda calculus (cont)\n\n\n\n\n\n\n\n\nJan 23 \n Jan 25\n\n\nScope, storage management, function implementation\n\n\nHaskell crash course\n\n\nHaskell crash course (cont)\n\n\n\n\n\n\nJan 30 \n Feb 01\n\n\nType polymorphism and type inference\n\n\nType polymorphism and type inference (cont)\n\n\nMidterm review\n\n\n\n\n\n\nFeb 06 \n Feb 08\n\n\nMidterm\n\n\nType classes\n\n\n\n\n\n\n\n\nFeb 13 \n Feb 15\n\n\nType classes (cont)\n\n\nObjects\n\n\n\n\n\n\n\n\nFeb 20 \n Feb 22\n\n\nObjects (cont)\n\n\nvtables, subtyping, inheritance\n\n\n\n\n\n\n\n\nFeb 27 \n Mar 01\n\n\nControl flow, continuations, monads\n\n\nControl flow, continuations, monads (cont)\n\n\n\n\n\n\n\n\nMar 06 \n Mar 08\n\n\nRust crash course\n\n\nConcurrency (cont)\n\n\nRust crash course (cont)\n\n\n\n\n\n\nMar 13 \n Mar 15\n\n\nConcurrency (cont)\n\n\nConcurrency (cont)\n\n\n\n\n\n\n\n\n\n\nTenative release dates for assignments:\n\n\n\n\nWritten homeworks:\n Jan 17, Jan 24, Jan 31, Feb 14, Feb 20\n\n\nProgramming labs:\n Jan 12, Jan 26, Feb 09, Feb 23, Mar 09", 
            "title": "Syllabus"
        }, 
        {
            "location": "/syllabus/#tenative-release-dates-for-assignments", 
            "text": "Written homeworks:  Jan 17, Jan 24, Jan 31, Feb 14, Feb 20  Programming labs:  Jan 12, Jan 26, Feb 09, Feb 23, Mar 09", 
            "title": "Tenative release dates for assignments:"
        }, 
        {
            "location": "/about/", 
            "text": "The course consists of lectures, written homeworks, and programming labs.  The\ngoal of the course is to \n(1)\n familiarize you with various modern\nprogramming language concepts and paradigms and \n(2)\n get you to think about\nand understand the design trade-offs and implementations of different language\nfeatures. We will use real-world languages (e.g., JavaScript, Haskell, C++, and\nRust) to explore the different concepts. But, we will not cover any one\nlanguage in full -- this course is not meant to make you a proficient\nprogrammer, learning how to proficiently program in any of these languages is a\ncourse in and of itself.\n\n\nGrading\n\n\n\n\n5% Participation in class and online\n\n\n35% Homeworks and programming labs\n\n\n25% Midterm exam\n\n\n35% Final exam\n\n\n\n\nParticipation/pre-lecture readings\n\n\nBefore each class there will be some assigned reading. You are expected to do\nthe reading and have at least a vague understanding of the concepts that will\nbe discussed in class. This will allow us to spend the lecture time to solidify\nyour understanding.  Asking and answering questions in class, on Piazza, or\nduring office hours counts towards your class participation. \n\n\nHomework and programming labs\n\n\nWe will have written homework assignments and programming labs.  Both are meant\nto both reinforce your knowledge of the concepts covered in lecture and get you\nto think about PL in more depth, beyond what is covered lecture (e.g., if you\nwere tasked with designing a new language).\n\n\nYou are expected to work on written assignments in groups of 3. All written\nhomework must be typeset and submitted as a PDF using the online submission\ntool.  All written assignments must be submitted as a group.  Homeworks will be\nreleased Wednesdays and will be due the following Friday night (10 days). If\nyou turn it in early -- the following Tuesday (7 days) -- you will\nreceive an additional 10% of your grade. There are no late days.\n\n\nYou are expected to work on the programming labs by yourself. You may discuss\nthe assignments with students from the course, in general, but not any specific\nsolution. Programming assignments will be released Fridays and will be due 2\nweeks later on Friday night. There are no late days.\n\n\nIf you consult anything (books, academic papers, internet resources, people not\nin your group) when working on the assignments, note this in your submission.\nWe encourage outside learning but expect you to not seek out specific details\nabout a solution -- anything submitted should be considered your own work.\nSimilarly, you are expected to not publish or otherwise share your solutions at\nany point (even after the class is over).\n\n\nIf you are unsure about what is allowed, please ask the course staff.\n\n\nWe will have a 5 written homeworks and 5 programming labs. They equally count\ntowards 35% of your grade.\n\n\nTentative release dates for assignments\n\n\nAll assignments and solutions will be posted on Piazza. All are to be turned in\nvia gradescope. We will be releasing them on the following dates:\n\n\n\n\nWritten homeworks: Jan 17, Jan 24, Jan 31, Feb 14, Feb 20\n\n\nProgramming labs: Jan 12, Jan 26, Feb 09, Feb 23, Mar 09\n\n\n\n\nExams\n\n\nThe midterm exam will be held on \nFebruary 6th\n, in class. The midterm is\n\nclosed-book\n, but you may use a double-sided cheat sheet (letter-size).\n\n\nThe final exam will be held on March 20th in \nTBA\n from 7:00PM-9:59PM. You\n\nmust\n take the exam at this time and location.  The final is\n\nclosed-book\n, but you may use 2 double-sided cheat sheets (letter-size).\n\n\nThe exams will make up 60% of your grade. Since the final is cumulative your\nmidterm grade will be calculated as:\n\n\nmidterm \n 0 ?  max(final, midterm) : 0\n\n\n\n\n\nThis means that (1) you basically get a second chance if you don't so well on\nthe midterm and (2) you must show up to both the midterm and the final.  If you\nneed to miss either exam because of a documented medical emergency, contact the\ninstructor immediately.\n\n\nAcademic integrity and student conduct\n\n\nBy taking this course, you implicitly agree to abide by the UCSD policies on \nIntegrity\nof Scholarship\n and \nStudent Conduct\n.\nUniversity rules on integrity of scholarship and code of conduct are taken\nseriously and will be enforced.", 
            "title": "Organization"
        }, 
        {
            "location": "/about/#grading", 
            "text": "5% Participation in class and online  35% Homeworks and programming labs  25% Midterm exam  35% Final exam", 
            "title": "Grading"
        }, 
        {
            "location": "/about/#participationpre-lecture-readings", 
            "text": "Before each class there will be some assigned reading. You are expected to do\nthe reading and have at least a vague understanding of the concepts that will\nbe discussed in class. This will allow us to spend the lecture time to solidify\nyour understanding.  Asking and answering questions in class, on Piazza, or\nduring office hours counts towards your class participation.", 
            "title": "Participation/pre-lecture readings"
        }, 
        {
            "location": "/about/#homework-and-programming-labs", 
            "text": "We will have written homework assignments and programming labs.  Both are meant\nto both reinforce your knowledge of the concepts covered in lecture and get you\nto think about PL in more depth, beyond what is covered lecture (e.g., if you\nwere tasked with designing a new language).  You are expected to work on written assignments in groups of 3. All written\nhomework must be typeset and submitted as a PDF using the online submission\ntool.  All written assignments must be submitted as a group.  Homeworks will be\nreleased Wednesdays and will be due the following Friday night (10 days). If\nyou turn it in early -- the following Tuesday (7 days) -- you will\nreceive an additional 10% of your grade. There are no late days.  You are expected to work on the programming labs by yourself. You may discuss\nthe assignments with students from the course, in general, but not any specific\nsolution. Programming assignments will be released Fridays and will be due 2\nweeks later on Friday night. There are no late days.  If you consult anything (books, academic papers, internet resources, people not\nin your group) when working on the assignments, note this in your submission.\nWe encourage outside learning but expect you to not seek out specific details\nabout a solution -- anything submitted should be considered your own work.\nSimilarly, you are expected to not publish or otherwise share your solutions at\nany point (even after the class is over).  If you are unsure about what is allowed, please ask the course staff.  We will have a 5 written homeworks and 5 programming labs. They equally count\ntowards 35% of your grade.", 
            "title": "Homework and programming labs"
        }, 
        {
            "location": "/about/#tentative-release-dates-for-assignments", 
            "text": "All assignments and solutions will be posted on Piazza. All are to be turned in\nvia gradescope. We will be releasing them on the following dates:   Written homeworks: Jan 17, Jan 24, Jan 31, Feb 14, Feb 20  Programming labs: Jan 12, Jan 26, Feb 09, Feb 23, Mar 09", 
            "title": "Tentative release dates for assignments"
        }, 
        {
            "location": "/about/#exams", 
            "text": "The midterm exam will be held on  February 6th , in class. The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size).  The final exam will be held on March 20th in  TBA  from 7:00PM-9:59PM. You must  take the exam at this time and location.  The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size).  The exams will make up 60% of your grade. Since the final is cumulative your\nmidterm grade will be calculated as:  midterm   0 ?  max(final, midterm) : 0  This means that (1) you basically get a second chance if you don't so well on\nthe midterm and (2) you must show up to both the midterm and the final.  If you\nneed to miss either exam because of a documented medical emergency, contact the\ninstructor immediately.", 
            "title": "Exams"
        }, 
        {
            "location": "/about/#academic-integrity-and-student-conduct", 
            "text": "By taking this course, you implicitly agree to abide by the UCSD policies on  Integrity\nof Scholarship  and  Student Conduct .\nUniversity rules on integrity of scholarship and code of conduct are taken\nseriously and will be enforced.", 
            "title": "Academic integrity and student conduct"
        }, 
        {
            "location": "/contact/", 
            "text": "For general information and questions, please post to the class\n\nPiazza\n.  It's very likely that\nother students will have the same question. We will post announcements on\nPiazza, so please make sure to sign up.  For urgent or personal matters, please\npost a private question or contact the course staff by email.\n\n\nCourse staff email address:\n \n\n\nInstructor\n\n\n\n\nName:\n \nDeian Stefan\n\n\nEmail:\n \n\n\nAddress:\n CSE 3126\n\n\nOffice Hours:\n Tuesday 11AM-12PM, CSE 3126\n\n\n\n\nTeaching Assistants\n\n\n\n\nName:\n Kaiser Pister\n\n\nOffice hours:\n Monday 6-8PM, CSE B240A\n\n\n\nName:\n Purag Moumdjian\n\n\nOffice hours:\n Tuesday 1-2pm, CSE B260A\n\n\n\nName:\n Nadah Feteih\n\n\nOffice hours:\n Wednesday 1-2PM, CSE B260A\n\n\n\nName:\n Sanjeev T Reddy\n\n\nOffice hours:\n Thursday 5-6PM, CSE B240A\n\n\n\nName:\n Abdulrahman Alkhelaifi\n\n\nOffice hours:\n Friday 3-4pm, CSE B240A", 
            "title": "Contact information"
        }, 
        {
            "location": "/contact/#instructor", 
            "text": "Name:   Deian Stefan  Email:    Address:  CSE 3126  Office Hours:  Tuesday 11AM-12PM, CSE 3126", 
            "title": "Instructor"
        }, 
        {
            "location": "/contact/#teaching-assistants", 
            "text": "Name:  Kaiser Pister  Office hours:  Monday 6-8PM, CSE B240A  Name:  Purag Moumdjian  Office hours:  Tuesday 1-2pm, CSE B260A  Name:  Nadah Feteih  Office hours:  Wednesday 1-2PM, CSE B260A  Name:  Sanjeev T Reddy  Office hours:  Thursday 5-6PM, CSE B240A  Name:  Abdulrahman Alkhelaifi  Office hours:  Friday 3-4pm, CSE B240A", 
            "title": "Teaching Assistants"
        }, 
        {
            "location": "/lectures/week1/", 
            "text": "Lecture slides and code\n\n\n\n\nIntroduction: \npdf\n, \nkey\n\n\nJavaScript in a Nutshell: \npdf\n, \nkey\n\n\nDiscussion section notes: \nhere\n\n\n\n\nRecommended reading\n\n\nIf you have not worked with JavaScript before, take some time to familiarize\nyourself with the basics of the language, as most of the labs in this class\nwill be in JavaScript.\n\n\nWe recommend the \nMozilla Developer Network's JavaScript\nGuide\n, but\nthere are many other tutorials on the Internet.\n\n\nDave Herman's \nEffective JavaScript\n is very good\nreference that covers a lot of the JavaScript intricacies.  You will not need\nthis for the class, but if you end up writing JavaScript code in the outside\nworld, this book is must-read.\n\n\nAdditional resources/reading for the curious\n\n\n\n\nBlock\n  bindings\n\n  and the difference between \nvar\n, \nlet\n, and \nconst\n.\n\n\nWhy a language like JavaScript took over the world? Not that uncommon, see\n  \nThe Rise of \"Worse is\n  Better\"\n.\n\n\nClosures\n\n  explained; see, especially the creating closures in a loop section.\n\n\nPrivate properties in (modern) JavaScript\n; we will revisit the idea of private properties (encapsulation) later in the course.\n\n\nShort intro to memory management for\n  JavaScript\n.\n\n\nES6 In Depth\n contains\n  more information on the more recent features introduced to JavaScript.\n\n\nArrow functions\n.\n\n\nJavaScript No-No's\n.\n\n\n\n\nSource code used in class\n\n\nBelow you'll find the source files we used during lecture. You can run these\nwith \nNode.js\n.\n\n\nScoping\n\n\nBlock scoping in modern JS:\n\n\nfunction\n \nhello\n(\nx\n)\n \n{\n\n  \nconsole\n.\nlog\n(\n`A: x = \n${\nx\n}\n`\n);\n \n// 42\n\n  \n{\n\n    \nlet\n \nx\n \n=\n \n45\n;\n\n    \nconsole\n.\nlog\n(\n`B: x = \n${\nx\n}\n`\n);\n \n// 45\n\n  \n}\n\n  \n{\n\n    \nconsole\n.\nlog\n(\n`C: x = \n${\nx\n}\n`\n);\n \n// 42\n\n  \n}\n\n\n}\n\n\n\nhello\n(\n42\n);\n\n\n\n\n\n\nFunction (but not block) scoping for \nvar\ns:\n\n\nfunction\n \nhello\n(\nx\n)\n \n{\n\n  \nconsole\n.\nlog\n(\n`A: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n{\n\n    \nvar\n \nx\n \n=\n \n45\n;\n\n    \nconsole\n.\nlog\n(\n`B: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n}\n\n  \n{\n\n    \nconsole\n.\nlog\n(\n`C: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n}\n\n\n}\n\n\n\nhello\n(\n42\n);\n\n\n\n\n\n\nMimicking block scoping with functions:\n\n\nfunction\n \nhello\n(\nx\n)\n \n{\n\n  \nconsole\n.\nlog\n(\n`A: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n(\nfunction\n \n()\n \n{\n\n    \nvar\n \nx\n \n=\n \n45\n;\n\n    \nconsole\n.\nlog\n(\n`B: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n})();\n\n  \n(\nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\n`C: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n})();\n\n\n}\n\n\n\nhello\n(\n42\n);\n\n\n\n\n\n\nNow, with arrow functions:\n\n\nfunction\n \nhello\n(\nx\n)\n \n{\n\n  \nconsole\n.\nlog\n(\n`A: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n(\nfunction\n \n()\n \n{\n\n    \nvar\n \nx\n \n=\n \n45\n;\n\n    \nconsole\n.\nlog\n(\n`B: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n})();\n\n  \n(()\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\n`C: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n})();\n\n\n}\n\n\n\nhello\n(\n42\n);\n\n\n\n\n\n\nPerformance\n\n\nWithout high-order functions, we'd perform reads and write synchronously:\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nconst\n \nr1\n \n=\n \nfs\n.\nreadFileSync\n(\n./perf-sync.js\n,\n \nutf8\n);\n \n// blocks until read is done\n\n\nprocessFile\n(\nperf-sync.js\n,\n \nr1\n);\n \n// blocks until processing (write) is done\n\n\nconst\n \nr2\n \n=\n \nfs\n.\nreadFileSync\n(\n./perf-async.js\n,\n \nutf8\n);\n \n// etc.\n\n\nprocessFile\n(\nperf-async.js\n,\n \nr2\n);\n\n\n\n// note that you can declare a function after the point it\ns used. Hoisting\n\n\n// essentially moves it to the top.\n\n\nfunction\n \nprocessFile\n(\nfname\n,\n \nstr\n)\n \n{\n\n  \nfs\n.\nwriteFileSync\n(\n`/tmp/\n${\nfname\n}\n`\n,\n \nstr\n);\n\n  \nconsole\n.\nlog\n(\n`DONE writing /tmp/\n${\nfname\n}\n`\n);\n\n\n}\n\n\n\n\n\n\nPassing (callback) functions as arguments allows the runtime system to call our function whenever it's ready. This allows it to perform IO concurrently and more efficiently:\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nfs\n.\nreadFile\n(\n./perf-sync.js\n,\n \nutf8\n,\n \ncb1\n);\n \n// returns immediately, cb1 is queued on the event loop and called later when actual file read is done\n\n\nfs\n.\nreadFile\n(\n./perf-async.js\n,\n \nutf8\n,\n \ncb2\n);\n \n// returns immediately, \n \n\n\n\nfunction\n \nprocessFile\n(\nfname\n,\n \nstr\n)\n \n{\n\n  \nfs\n.\nwriteFileSync\n(\n`/tmp/\n${\nfname\n}\n`\n,\n \nstr\n);\n\n  \nconsole\n.\nlog\n(\n`DONE writing /tmp/\n${\nfname\n}\n`\n);\n\n\n}\n\n\n\nfunction\n \ncb1\n(\nerr\n,\n \nstr\n)\n \n{\n\n  \n// line cb1.1\n\n  \nprocessFile\n(\nperf-sync.js\n,\n \nstr\n);\n\n\n}\n\n\n\nfunction\n \ncb2\n(\nerr\n,\n \nstr\n)\n \n{\n\n  \n//line cb2.1\n\n  \nprocessFile\n(\nperf-async.js\n,\n \nstr\n);\n\n\n}\n\n\n\nCan\n \ncb2\n \nexecute\n \nbefore\n \ncb1\n?\n\n\nA\n:\n \nyes\n,\n \nB\n:\n \nno\n\n\n\n\n\n\nOnce we can return functions we can also express our code more compactly too:\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nfs\n.\nreadFile\n(\n./perf-sync.js\n,\n \nutf8\n,\n \nprocessFile\n(\nperf-sync.js\n));\n\n\nfs\n.\nreadFile\n(\n./perf-async.js\n,\n \nutf8\n,\n \nprocessFile\n(\nperf-async.js\n));\n\n\n\nfunction\n \nprocessFile\n(\nfname\n)\n \n{\n\n  \nreturn\n \n(\nerr\n,\n \nstr\n)\n \n=\n \n{\n\n    \nfs\n.\nwriteFileSync\n(\n`/tmp/\n${\nfname\n}\n`\n,\n \nstr\n);\n\n    \nconsole\n.\nlog\n(\n`DONE writing /tmp/\n${\nfname\n}\n`\n);\n\n  \n};\n\n\n}\n\n\n\n\n\n\nAnd, slightly cleaner:\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nreadAndProcessFile\n(\nperf-sync.js\n);\n\n\nreadAndProcessFile\n(\nperf-async.js\n);\n\n\n\nfunction\n \nreadAndProcessFile\n(\nname\n)\n \n{\n\n  \nreturn\n \nfs\n.\nreadFile\n(\n`./\n${\nname\n}\n`\n,\n \nutf8\n,\n \nprocessFile\n(\nname\n));\n\n\n}\n\n\n\nfunction\n \nprocessFile\n(\nfname\n)\n \n{\n\n  \nreturn\n \n(\nerr\n,\n \nstr\n)\n \n=\n \n{\n\n    \nfs\n.\nwriteFileSync\n(\n`/tmp/\n${\nfname\n}\n`\n,\n \nstr\n);\n\n    \nconsole\n.\nlog\n(\n`DONE writing /tmp/\n${\nfname\n}\n`\n);\n\n  \n};\n\n\n}\n\n\n\n\n\n\nExpressiveness\n\n\nHigh-order functions enables expressiveness:\n\n\nconst\n \nlist\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n];\n\n\n\nconsole\n.\nlog\n(\nfilter\n(\nlist\n,\n \nfunction\n \n(\nel\n)\n \n{\n \n  \nreturn\n \nel\n \n \n2\n;\n\n\n}));\n \n// ??\n\n\n\nconsole\n.\nlog\n(\nmap\n(\nlist\n,\n \nel\n \n=\n \n{\n \n  \nreturn\n \nel\n \n+\n \n42\n;\n\n\n}));\n \n// ??\n\n\n\n\nfunction\n \nfilter\n(\nlist\n,\n \npred\n)\n \n{\n\n  \nconst\n \ndup\n \n=\n \n[];\n\n  \nfor\n \n(\nlet\n \ni\n \n=\n \n0\n;\n \ni\n \n \nlist\n.\nlength\n;\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\npred\n(\nlist\n[\ni\n]))\n \n{\n\n      \ndup\n.\npush\n(\nlist\n[\ni\n]);\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ndup\n;\n\n\n}\n\n\n\nfunction\n \nmap\n(\nlist\n,\n \nf\n)\n \n{\n\n  \nconst\n \ndup\n \n=\n \n[];\n\n  \nfor\n \n(\nlet\n \ni\n \n=\n \nlist\n.\nlength\n-\n1\n;\n \ni\n \n=\n \n0\n;\n \ni\n--\n)\n \n{\n\n    \ndup\n.\nunshift\n(\nf\n(\nlist\n[\ni\n]));\n\n  \n}\n\n  \nreturn\n \ndup\n;\n\n\n}\n\n\n\n\n\n\nIt also can enable more efficient code:\n\n\nconst\n \nlist\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n];\n\n\n\nconst\n \nadd42\n \n=\n \n(\nel\n)\n \n=\n \n{\n\n  \nreturn\n \nel\n \n+\n \n42\n;\n\n\n};\n\n\n\nfunction\n \nmul1337\n \n(\nel\n)\n \n{\n\n  \nreturn\n \nel\n \n*\n \n1337\n;\n\n\n}\n\n\n\nconsole\n.\nlog\n(\nmap\n(\nmap\n(\nlist\n,\n \nadd42\n),\n \nmul1337\n));\n\n\nconsole\n.\nlog\n(\nmap\n(\nlist\n,\n \ncompose\n(\nmul1337\n,\n \nadd42\n)));\n\n\n\nfunction\n \ncompose\n \n(\nf\n,\n \ng\n)\n \n{\n\n  \nreturn\n \n(\nx\n)\n \n=\n \n{\n \n    \nreturn\n \nf\n(\ng\n(\nx\n));\n\n  \n}\n\n\n}\n\n\n\nfunction\n \nmap\n(\nlist\n,\n \nf\n)\n \n{\n\n  \nconst\n \ndup\n \n=\n \n[];\n\n  \nfor\n \n(\nlet\n \ni\n \n=\n \nlist\n.\nlength\n-\n1\n;\n \ni\n \n=\n \n0\n;\n \ni\n--\n)\n \n{\n\n    \ndup\n.\nunshift\n(\nf\n(\nlist\n[\ni\n]));\n\n  \n}\n\n  \nreturn\n \ndup\n;\n\n\n}\n\n\n\n\n\n\nAbstraction\n\n\nWe can also use functions to implement module systems.\n\n\nConsider a simple module in Node.js:\n\n\nconst\n \nsecret\n \n=\n \ncse130 is fun!\n;\n \n// scoped to this function, hidden to outside world\n\n\nexports\n.\nmyVar\n \n=\n \n42\n;\n\n\nexports\n.\nmyFunc\n \n=\n \nfunction\n \n(\nx\n)\n \n{\n\n  \nif\n \n(\nx\n \n===\n \nsecret\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nyes!\n);\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nguess again!\n);\n\n  \n}\n\n\n};\n\n\n\n\n\n\nThis module can be loaded with \nrequire\n, which is (very) roughly implemented\nas follows:\n\n\n// using node\ns requie:\n\n\n{\n\n  \nconst\n \nmod\n \n=\n \nrequire\n(\n./module-node.js\n);\n\n\n  \nconsole\n.\nlog\n(\nmod\n.\nmyVar\n);\n \n// ??\n\n  \nmod\n.\nmyFunc\n(\nwhat?\n);\n \n// ??\n\n  \nmod\n.\nmyFunc\n(\ncse130 is fun!\n);\n \n// ??\n\n\n}\n\n\n\n// using our fake require:\n\n\n{\n\n  \nconst\n \nmod\n \n=\n \nrequireMyModule\n();\n\n\n  \nconsole\n.\nlog\n(\nmod\n.\nmyVar\n);\n \n// ??\n\n  \nmod\n.\nmyFunc\n(\nwhat?\n);\n \n// ??\n\n  \nmod\n.\nmyFunc\n(\ncse130 is fun!\n);\n \n// ??\n\n\n}\n\n\n\nfunction\n \nmyModule\n(\nexports\n)\n \n{\n\n  \n// same code as module-node.js:\n\n  \nconst\n \nsecret\n \n=\n \ncse130 is fun!\n;\n \n// scoped to this function, hidden to outside world\n\n  \nexports\n.\nmyVar\n \n=\n \n42\n;\n\n  \nexports\n.\nmyFunc\n \n=\n \nfunction\n \n(\nx\n)\n \n{\n\n    \nif\n \n(\nx\n \n===\n \nsecret\n)\n \n{\n\n      \nconsole\n.\nlog\n(\nyes!\n);\n\n    \n}\n \nelse\n \n{\n\n      \nconsole\n.\nlog\n(\nguess again!\n);\n\n    \n}\n\n  \n};\n\n\n}\n\n\n\nfunction\n \nrequireMyModule\n()\n \n{\n\n  \n// create new object that will be populated by the module\n\n  \nconst\n \nexports\n \n=\n \n{};\n\n  \nmyModule\n(\nexports\n);\n\n  \nreturn\n \nexports\n;\n\n\n}\n\n\n\n\n\n\nObjects\n\n\nWe'll be looking at objects later in the class. Objects can be expressed\nad-hoc, using object literal notation:\n\n\nconst\n \nobj\n \n=\n \n{\n\n  \nx-w00t\n:\n \n10\n,\n\n  \nx\n:\n \n1337\n,\n\n  \nf\n:\n \nfunction\n \n(\ny\n)\n \n{\n\n    \nthis\n.\nx\n++\n;\n\n    \nreturn\n \nthis\n.\nx\n \n+\n \ny\n;\n\n  \n}\n\n\n};\n\n\n\nconsole\n.\nlog\n(\nobj\n.\nx\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\nobj\n.\nf\n(\n3\n));\n \n// ??\n\n\nconsole\n.\nlog\n(\nobj\n[\nx\n]);\n \n// ??\n\n\nconsole\n.\nlog\n(\nobj\n[\nx-w00t\n])\n \n// ??\n\n\n\n\n\n\nBut we can (again) use functions to construct objects:\n\n\nfunction\n \nCar\n(\nmake\n,\n \nmodel\n)\n \n{\n\n  \nthis\n.\nmake\n \n=\n \nmake\n;\n\n  \nthis\n.\nmodel\n \n=\n \nmodel\n;\n\n  \nthis\n.\ntoString\n \n=\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \n`\n${\nthis\n.\nmake\n}\n@\n${\nthis\n.\nmodel\n}\n`\n;\n\n  \n};\n\n\n}\n\n\nCar\n.\nmySweetProp\n \n=\n \n42\n;\n\n\n\nconst\n \nf\n \n=\n \nnew\n \nCar\n(\nFord\n,\n \nFocus\n);\n\n\nconsole\n.\nlog\n(\nf\n.\ntoString\n());\n\n\nconst\n \nt\n \n=\n \nnew\n \nCar\n(\nToyota\n,\n \nCorola\n);\n\n\nconsole\n.\nlog\n(\nt\n.\ntoString\n());\n\n\n\n// Car.prototype is shared by all objects created by calling new Car(...)\n\n\n// That\ns right you can treat functions like objects!\n\n\n\nconsole\n.\nlog\n(\nf\n.\n__proto__\n \n===\n \nCar\n.\nprototype\n);\n \n// ??\n\n\n\n// Let\ns define property common to all cars:\n\n\nCar\n.\nprototype\n.\ncolor\n \n=\n \nblack\n;\n\n\n\nconsole\n.\nlog\n(\nf\n.\ncolor\n);\n \n// ??\n\n\n// getProperty \ncolor\n of f\n\n\n//     if it has it, return it\n\n\n//     else getProperty \ncolor\n of f.__proto__\n\n\nconsole\n.\nlog\n(\nt\n.\ncolor\n);\n \n// ??\n\n\n\n// Can override the default color that is defined on the prototype:\n\n\n\nt\n.\ncolor\n \n=\n \nred\n;\n\n\n\nconsole\n.\nlog\n(\nt\n.\ncolor\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\nf\n.\ncolor\n);\n \n// ??\n\n\n\n// We can define a method on the prototype:\n\n\n\nCar\n.\nprototype\n.\ntoColorString\n \n=\n \nfunction\n \n()\n \n{\n\n  \nreturn\n \n`\n${\nthis\n.\nmake\n}\n, \n${\nthis\n.\nmodel\n}\n, \n${\nthis\n.\ncolor\n}\n`\n;\n\n\n};\n\n\n\nconsole\n.\nlog\n(\nf\n.\ntoColorString\n());\n \n// ??\n\n\nconsole\n.\nlog\n(\nt\n.\ntoColorString\n());\n \n// ??\n\n\n\n\n\n\nMore recently, however, JavaScript adopted classes. You can think of them as\nbeing \nsyntactic sugar\n for the above:\n\n\nclass\n \nCar\n \n{\n\n  \nconstructor\n(\nmake\n,\n \nmodel\n)\n \n{\n\n    \nthis\n.\nmake\n \n=\n \nmake\n;\n\n    \nthis\n.\nmodel\n \n=\n \nmodel\n;\n\n  \n}\n\n  \ntoString\n()\n \n{\n\n    \nreturn\n \n`\n${\nthis\n.\nmake\n}\n@\n${\nthis\n.\nmodel\n}\n`\n;\n\n  \n}\n\n  \nstatic\n \nget\n \nmySweetProp\n()\n \n{\n\n    \nreturn\n \n42\n;\n\n  \n}\n\n\n}\n\n\n\nconst\n \nf\n \n=\n \nnew\n \nCar\n(\nFord\n,\n \nFocus\n);\n\n\nconsole\n.\nlog\n(\nf\n.\ntoString\n());\n\n\nconst\n \nt\n \n=\n \nnew\n \nCar\n(\nToyota\n,\n \nCorola\n);\n\n\nconsole\n.\nlog\n(\nt\n.\ntoString\n());\n\n\n\n// Car.prototype is shared by all objects created by calling new Car(...)\n\n\n// That\ns right you can treat functions like objects!\n\n\n\nconsole\n.\nlog\n(\nf\n.\n__proto__\n \n===\n \nCar\n.\nprototype\n);\n \n// ??\n\n\n\n// We can define property common to all cars as before:\n\n\nCar\n.\nprototype\n.\ncolor\n \n=\n \nblack\n;\n\n\n\nconsole\n.\nlog\n(\nf\n.\ncolor\n);\n \n// ??\n\n\n// getProperty \ncolor\n of f\n\n\n//     if it has it, return it\n\n\n//     else getProperty \ncolor\n of f.__proto__\n\n\nconsole\n.\nlog\n(\nt\n.\ncolor\n);\n \n// ??\n\n\n\n// Can override the default color that is defined on the prototype:\n\n\n\nt\n.\ncolor\n \n=\n \nred\n;\n\n\n\nconsole\n.\nlog\n(\nt\n.\ncolor\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\nf\n.\ncolor\n);\n \n// ??\n\n\n\n// We can define a method on the prototype as before:\n\n\n\nCar\n.\nprototype\n.\ntoColorString\n \n=\n \nfunction\n \n()\n \n{\n\n  \nreturn\n \n`\n${\nthis\n.\nmake\n}\n, \n${\nthis\n.\nmodel\n}\n, \n${\nthis\n.\ncolor\n}\n`\n;\n\n\n};\n\n\n\nconsole\n.\nlog\n(\nf\n.\ntoColorString\n());\n \n// ??\n\n\nconsole\n.\nlog\n(\nt\n.\ntoColorString\n());\n \n// ??", 
            "title": "Week 1"
        }, 
        {
            "location": "/lectures/week1/#lecture-slides-and-code", 
            "text": "Introduction:  pdf ,  key  JavaScript in a Nutshell:  pdf ,  key  Discussion section notes:  here", 
            "title": "Lecture slides and code"
        }, 
        {
            "location": "/lectures/week1/#recommended-reading", 
            "text": "If you have not worked with JavaScript before, take some time to familiarize\nyourself with the basics of the language, as most of the labs in this class\nwill be in JavaScript.  We recommend the  Mozilla Developer Network's JavaScript\nGuide , but\nthere are many other tutorials on the Internet.  Dave Herman's  Effective JavaScript  is very good\nreference that covers a lot of the JavaScript intricacies.  You will not need\nthis for the class, but if you end up writing JavaScript code in the outside\nworld, this book is must-read.", 
            "title": "Recommended reading"
        }, 
        {
            "location": "/lectures/week1/#additional-resourcesreading-for-the-curious", 
            "text": "Block\n  bindings \n  and the difference between  var ,  let , and  const .  Why a language like JavaScript took over the world? Not that uncommon, see\n   The Rise of \"Worse is\n  Better\" .  Closures \n  explained; see, especially the creating closures in a loop section.  Private properties in (modern) JavaScript ; we will revisit the idea of private properties (encapsulation) later in the course.  Short intro to memory management for\n  JavaScript .  ES6 In Depth  contains\n  more information on the more recent features introduced to JavaScript.  Arrow functions .  JavaScript No-No's .", 
            "title": "Additional resources/reading for the curious"
        }, 
        {
            "location": "/lectures/week1/#source-code-used-in-class", 
            "text": "Below you'll find the source files we used during lecture. You can run these\nwith  Node.js .", 
            "title": "Source code used in class"
        }, 
        {
            "location": "/lectures/week1/#scoping", 
            "text": "Block scoping in modern JS:  function   hello ( x )   { \n   console . log ( `A: x =  ${ x } ` );   // 42 \n   { \n     let   x   =   45 ; \n     console . log ( `B: x =  ${ x } ` );   // 45 \n   } \n   { \n     console . log ( `C: x =  ${ x } ` );   // 42 \n   }  }  hello ( 42 );   Function (but not block) scoping for  var s:  function   hello ( x )   { \n   console . log ( `A: x =  ${ x } ` );   // ?? \n   { \n     var   x   =   45 ; \n     console . log ( `B: x =  ${ x } ` );   // ?? \n   } \n   { \n     console . log ( `C: x =  ${ x } ` );   // ?? \n   }  }  hello ( 42 );   Mimicking block scoping with functions:  function   hello ( x )   { \n   console . log ( `A: x =  ${ x } ` );   // ?? \n   ( function   ()   { \n     var   x   =   45 ; \n     console . log ( `B: x =  ${ x } ` );   // ?? \n   })(); \n   ( function   ()   { \n     console . log ( `C: x =  ${ x } ` );   // ?? \n   })();  }  hello ( 42 );   Now, with arrow functions:  function   hello ( x )   { \n   console . log ( `A: x =  ${ x } ` );   // ?? \n   ( function   ()   { \n     var   x   =   45 ; \n     console . log ( `B: x =  ${ x } ` );   // ?? \n   })(); \n   (()   =   { \n     console . log ( `C: x =  ${ x } ` );   // ?? \n   })();  }  hello ( 42 );", 
            "title": "Scoping"
        }, 
        {
            "location": "/lectures/week1/#performance", 
            "text": "Without high-order functions, we'd perform reads and write synchronously:  const   fs   =   require ( fs );  const   r1   =   fs . readFileSync ( ./perf-sync.js ,   utf8 );   // blocks until read is done  processFile ( perf-sync.js ,   r1 );   // blocks until processing (write) is done  const   r2   =   fs . readFileSync ( ./perf-async.js ,   utf8 );   // etc.  processFile ( perf-async.js ,   r2 );  // note that you can declare a function after the point it s used. Hoisting  // essentially moves it to the top.  function   processFile ( fname ,   str )   { \n   fs . writeFileSync ( `/tmp/ ${ fname } ` ,   str ); \n   console . log ( `DONE writing /tmp/ ${ fname } ` );  }   Passing (callback) functions as arguments allows the runtime system to call our function whenever it's ready. This allows it to perform IO concurrently and more efficiently:  const   fs   =   require ( fs );  fs . readFile ( ./perf-sync.js ,   utf8 ,   cb1 );   // returns immediately, cb1 is queued on the event loop and called later when actual file read is done  fs . readFile ( ./perf-async.js ,   utf8 ,   cb2 );   // returns immediately,     function   processFile ( fname ,   str )   { \n   fs . writeFileSync ( `/tmp/ ${ fname } ` ,   str ); \n   console . log ( `DONE writing /tmp/ ${ fname } ` );  }  function   cb1 ( err ,   str )   { \n   // line cb1.1 \n   processFile ( perf-sync.js ,   str );  }  function   cb2 ( err ,   str )   { \n   //line cb2.1 \n   processFile ( perf-async.js ,   str );  }  Can   cb2   execute   before   cb1 ?  A :   yes ,   B :   no   Once we can return functions we can also express our code more compactly too:  const   fs   =   require ( fs );  fs . readFile ( ./perf-sync.js ,   utf8 ,   processFile ( perf-sync.js ));  fs . readFile ( ./perf-async.js ,   utf8 ,   processFile ( perf-async.js ));  function   processFile ( fname )   { \n   return   ( err ,   str )   =   { \n     fs . writeFileSync ( `/tmp/ ${ fname } ` ,   str ); \n     console . log ( `DONE writing /tmp/ ${ fname } ` ); \n   };  }   And, slightly cleaner:  const   fs   =   require ( fs );  readAndProcessFile ( perf-sync.js );  readAndProcessFile ( perf-async.js );  function   readAndProcessFile ( name )   { \n   return   fs . readFile ( `./ ${ name } ` ,   utf8 ,   processFile ( name ));  }  function   processFile ( fname )   { \n   return   ( err ,   str )   =   { \n     fs . writeFileSync ( `/tmp/ ${ fname } ` ,   str ); \n     console . log ( `DONE writing /tmp/ ${ fname } ` ); \n   };  }", 
            "title": "Performance"
        }, 
        {
            "location": "/lectures/week1/#expressiveness", 
            "text": "High-order functions enables expressiveness:  const   list   =   [ 1 ,   2 ,   3 ,   4 ];  console . log ( filter ( list ,   function   ( el )   {  \n   return   el     2 ;  }));   // ??  console . log ( map ( list ,   el   =   {  \n   return   el   +   42 ;  }));   // ??  function   filter ( list ,   pred )   { \n   const   dup   =   []; \n   for   ( let   i   =   0 ;   i     list . length ;   i ++ )   { \n     if   ( pred ( list [ i ]))   { \n       dup . push ( list [ i ]); \n     } \n   } \n   return   dup ;  }  function   map ( list ,   f )   { \n   const   dup   =   []; \n   for   ( let   i   =   list . length - 1 ;   i   =   0 ;   i -- )   { \n     dup . unshift ( f ( list [ i ])); \n   } \n   return   dup ;  }   It also can enable more efficient code:  const   list   =   [ 1 ,   2 ,   3 ,   4 ];  const   add42   =   ( el )   =   { \n   return   el   +   42 ;  };  function   mul1337   ( el )   { \n   return   el   *   1337 ;  }  console . log ( map ( map ( list ,   add42 ),   mul1337 ));  console . log ( map ( list ,   compose ( mul1337 ,   add42 )));  function   compose   ( f ,   g )   { \n   return   ( x )   =   {  \n     return   f ( g ( x )); \n   }  }  function   map ( list ,   f )   { \n   const   dup   =   []; \n   for   ( let   i   =   list . length - 1 ;   i   =   0 ;   i -- )   { \n     dup . unshift ( f ( list [ i ])); \n   } \n   return   dup ;  }", 
            "title": "Expressiveness"
        }, 
        {
            "location": "/lectures/week1/#abstraction", 
            "text": "We can also use functions to implement module systems.  Consider a simple module in Node.js:  const   secret   =   cse130 is fun! ;   // scoped to this function, hidden to outside world  exports . myVar   =   42 ;  exports . myFunc   =   function   ( x )   { \n   if   ( x   ===   secret )   { \n     console . log ( yes! ); \n   }   else   { \n     console . log ( guess again! ); \n   }  };   This module can be loaded with  require , which is (very) roughly implemented\nas follows:  // using node s requie:  { \n   const   mod   =   require ( ./module-node.js ); \n\n   console . log ( mod . myVar );   // ?? \n   mod . myFunc ( what? );   // ?? \n   mod . myFunc ( cse130 is fun! );   // ??  }  // using our fake require:  { \n   const   mod   =   requireMyModule (); \n\n   console . log ( mod . myVar );   // ?? \n   mod . myFunc ( what? );   // ?? \n   mod . myFunc ( cse130 is fun! );   // ??  }  function   myModule ( exports )   { \n   // same code as module-node.js: \n   const   secret   =   cse130 is fun! ;   // scoped to this function, hidden to outside world \n   exports . myVar   =   42 ; \n   exports . myFunc   =   function   ( x )   { \n     if   ( x   ===   secret )   { \n       console . log ( yes! ); \n     }   else   { \n       console . log ( guess again! ); \n     } \n   };  }  function   requireMyModule ()   { \n   // create new object that will be populated by the module \n   const   exports   =   {}; \n   myModule ( exports ); \n   return   exports ;  }", 
            "title": "Abstraction"
        }, 
        {
            "location": "/lectures/week1/#objects", 
            "text": "We'll be looking at objects later in the class. Objects can be expressed\nad-hoc, using object literal notation:  const   obj   =   { \n   x-w00t :   10 , \n   x :   1337 , \n   f :   function   ( y )   { \n     this . x ++ ; \n     return   this . x   +   y ; \n   }  };  console . log ( obj . x );   // ??  console . log ( obj . f ( 3 ));   // ??  console . log ( obj [ x ]);   // ??  console . log ( obj [ x-w00t ])   // ??   But we can (again) use functions to construct objects:  function   Car ( make ,   model )   { \n   this . make   =   make ; \n   this . model   =   model ; \n   this . toString   =   function   ()   { \n     return   ` ${ this . make } @ ${ this . model } ` ; \n   };  }  Car . mySweetProp   =   42 ;  const   f   =   new   Car ( Ford ,   Focus );  console . log ( f . toString ());  const   t   =   new   Car ( Toyota ,   Corola );  console . log ( t . toString ());  // Car.prototype is shared by all objects created by calling new Car(...)  // That s right you can treat functions like objects!  console . log ( f . __proto__   ===   Car . prototype );   // ??  // Let s define property common to all cars:  Car . prototype . color   =   black ;  console . log ( f . color );   // ??  // getProperty  color  of f  //     if it has it, return it  //     else getProperty  color  of f.__proto__  console . log ( t . color );   // ??  // Can override the default color that is defined on the prototype:  t . color   =   red ;  console . log ( t . color );   // ??  console . log ( f . color );   // ??  // We can define a method on the prototype:  Car . prototype . toColorString   =   function   ()   { \n   return   ` ${ this . make } ,  ${ this . model } ,  ${ this . color } ` ;  };  console . log ( f . toColorString ());   // ??  console . log ( t . toColorString ());   // ??   More recently, however, JavaScript adopted classes. You can think of them as\nbeing  syntactic sugar  for the above:  class   Car   { \n   constructor ( make ,   model )   { \n     this . make   =   make ; \n     this . model   =   model ; \n   } \n   toString ()   { \n     return   ` ${ this . make } @ ${ this . model } ` ; \n   } \n   static   get   mySweetProp ()   { \n     return   42 ; \n   }  }  const   f   =   new   Car ( Ford ,   Focus );  console . log ( f . toString ());  const   t   =   new   Car ( Toyota ,   Corola );  console . log ( t . toString ());  // Car.prototype is shared by all objects created by calling new Car(...)  // That s right you can treat functions like objects!  console . log ( f . __proto__   ===   Car . prototype );   // ??  // We can define property common to all cars as before:  Car . prototype . color   =   black ;  console . log ( f . color );   // ??  // getProperty  color  of f  //     if it has it, return it  //     else getProperty  color  of f.__proto__  console . log ( t . color );   // ??  // Can override the default color that is defined on the prototype:  t . color   =   red ;  console . log ( t . color );   // ??  console . log ( f . color );   // ??  // We can define a method on the prototype as before:  Car . prototype . toColorString   =   function   ()   { \n   return   ` ${ this . make } ,  ${ this . model } ,  ${ this . color } ` ;  };  console . log ( f . toColorString ());   // ??  console . log ( t . toColorString ());   // ??", 
            "title": "Objects"
        }, 
        {
            "location": "/lectures/week2/", 
            "text": "Lecture slides\n\n\n\n\nFoundations and lambda calculus: \npdf\n, \nkey\n,\n\n\n\n\nRecommended reading\n\n\n\n\nTextbook: section 4.1.2 and section 4.2\n\n\nInformal notes on the Y combinator\n\n\nIntroduction to Lambda Calculus\n by Barendregt and Barendsen\n\n\nRanjit Jhala's lambda calculus \nslides\n and the\n  \nELSA\n project.", 
            "title": "Week 2"
        }, 
        {
            "location": "/lectures/week2/#lecture-slides", 
            "text": "Foundations and lambda calculus:  pdf ,  key ,", 
            "title": "Lecture slides"
        }, 
        {
            "location": "/lectures/week2/#recommended-reading", 
            "text": "Textbook: section 4.1.2 and section 4.2  Informal notes on the Y combinator  Introduction to Lambda Calculus  by Barendregt and Barendsen  Ranjit Jhala's lambda calculus  slides  and the\n   ELSA  project.", 
            "title": "Recommended reading"
        }, 
        {
            "location": "/lectures/week3/", 
            "text": "Lecture slides\n\n\n\n\nScope: \npdf\n, \nkey\n,\n\n\nHaskell: \npdf\n, \nkey\n,\n\n\n\n\nRecommended reading\n\n\n\n\nTextbook: Chapter 7 on Scope, \nChapter 5\n on Haskell.\n\n\nPhilip Guo's \nJavaScript tutor\n\n\n\n\nExternal sources\n\n\nIf you have not worked with Haskell before, take some time to familiarize\nyourself with the basics of the language. The chapter above is a good start.\nBut there are many other sources to take advantage of, including:\n\n\n\n\nBrent Yorgey's \nHaskell Basics\n lectures.\n\n\nLearn You a Haskell for Great Good!\n is also a good book to read through.\n\n\nA history of Haskell: Being lazy with class\n is a fantastic read, and there is a similarly engaging \ntalk\n. \n\n\nA history of Haskell: Being lazy with class\n is a fantastic read. \n\n\nA Gentle Introduction to Haskell 98\n \n\n\nThe Haskell 2010 Language\n\n\n\n\nSource code used in class\n\n\nBelow you'll find the source we used during lecture. You can run these with\nGHCi (e.g., from \nHaskell Platform\n).\n\n\nmodule\n \nIntro\n \nwhere\n\n\nimport\n \nPrelude\n \nhiding\n \n(\nEither\n(\n..\n))\n\n\n\n-- # Definitions and bindings\n\n\n\n-- * Haskell uses the = sign to declare symbol *bindings*:\n\n\n\nx\n \n=\n \n2\n\n\n\n-- * They are called variables, but they are not mutable boxes\n\n\n--   * They are like JS\ns const (but on steroids)\n\n\n\n-- x = 3  -- is this allowed?\n\n\n\n-- * \nlet\n introduces local bindings (new scope)\n\n\n\nexample0\n \n=\n \nlet\n \nx\n \n=\n \n44\n \n-- this \nshadows\n above x\n\n               \nz\n \n=\n \nx\n \n-\n \n2\n\n           \nin\n \nz\n \n*\n \n2\n\n           \n-- what is x here? A: 2, B: 44\n\n\n\n-- * Variables are order-independent\n\n\n\na\n \n=\n  \nif\n \ny\n\n      \nthen\n \na\n\n      \nelse\n \nb\n \n-- we use the y defined below:\n\n\ny\n \n=\n \nTrue\n\n\n\n-- # Essence of programming in Haskell\n\n\n\n-- * Everything is an expression\n\n\n-- * Expressions evaluate to values\n\n\n--    - What\ns the diff between expressions and values?\n\n\n-- * Programming in Haskell: substituting equals by equals\n\n\n--    - Lambda calculus for the win!\n\n\n\n{-\n\n\nexample0 = let x = 44\n\n\n               z = x - 2\n\n\n           in z * 2\n\n\n--\n\n\n         = let z = 44 - 2\n\n\n           in z * 2\n\n\n--\n\n\n         = (44 - 2) * 2\n\n\n--\n\n\n         = 42 * 2\n\n\n--\n\n\n         = 84\n\n\n-}\n\n\n\n-- # Every expression has a type\n\n\n\n-- * E.g., intVal is a word-sized integer\n\n\nintVal\n \n::\n \nInt\n\n\nintVal\n \n=\n \n31\n \n*\n \n(\n42\n \n+\n \n56\n)\n\n\n\n-- * E.g., ii is an Arbitrarily large integer\n\n\nii\n \n::\n \nInteger\n\n\nii\n \n=\n \n31\n \n*\n \n(\n42\n \n+\n \n56000000\n \n*\n \n1000\n)\n\n\n\n-- * E.g., dbl is a double precision floating point\n\n\ndbl\n \n=\n \n3\n \n*\n \n(\n4.2\n \n+\n \n5.6\n)\n\n\n\n-- * E.g., chr is a unicode character\n\n\nchr\n \n=\n \na\n \n::\n \nChar\n\n\n\n-- * E.g., str is a String = [Char]\n\n\nstr\n \n=\n \nw00t\n \n::\n \nString\n\n\n\nlistOfInt\n \n::\n \n[\nInt\n]\n\n\nlistOfInt\n \n=\n \n[\n1\n,\n2\n,\n3\n]\n\n\n\n-- * E.g., truth is a Boolean\n\n\ntruth\n \n=\n \nTrue\n \n::\n \nBool\n\n\n\n-- ## Some remarks about types\n\n\n\n{-\n\n\n   * We didn\nt need to add type annotations: Haskell infers types\n\n\n     - Inspect types in GHCi with :t\n\n\n     - You should generally specify types anyway. Why?\n\n\n   * Is this the same thing as not having to specify types in JS?\n\n\n     - A: yes, B: no\n\n\n-}\n\n\n\n-- * Haskell doesn\nt do any implicit conversions\n\n\n--   - What\ns the type of ii_x_dbl below:\n\n\n--     ii_x_dbl = ii + dbl :: ???\n\n\n--     - A: Double, B: Int, C: Type error\n\n\n\n-- * Arithmetic operators + and * are overloaded (as are some other)\n\n\n\nii_add\n  \n=\n \nii\n \n+\n \n33\n    \n-- :: ?\n\n\ndbl_add\n \n=\n \ndbl\n \n+\n \n33.0\n \n-- :: ?\n\n\n\n-- * We\nll talk about overloading more in the upcoming classes\n\n\n\n-- # Functions\n\n\n\n-- * Functions have \narrow types\n\n\npos\n \n::\n \nInteger\n \n-\n \nBool\n\n\n\n-- * Function arguments separated by space not (,)\ns\n\n\npos\n \nx\n \n=\n \nx\n \n \n0\n\n\n\n-- * As in JS, you can just use lambdas instead:\n\n\ngt\n \n::\n \nInt\n \n-\n \nInt\n \n-\n \nBool\n\n\ngt\n \n=\n \n\\\nx\n \ny\n \n-\n \nx\n \n \ny\n \n-- \\xy.(x \n y)\n\n\n\n-- * Function application is like in lambda calculus:\n\n\nis33pos\n \n=\n \npos\n \n33\n \n-- True\n\n\n\n-- * How you should NOT think about functions (or expressions):\n\n\n--   - What does this function do?\n\n\n\n-- * How you should think: what does this mean? Think math!\n\n\n-- * In Haskell, f :: A -\n B means:\n\n\n--   - For every element x \u2208 A,\n\n\n--      f(x) = y for some some element y \u2208 B \n\n\n--      or f(x) diverges\n\n\n\n-- ## Multi-argument functions\n\n\n\n-- * Functions can take multiple arguments\n\n\n\narith\n \n::\n \nInt\n \n-\n \nInt\n \n-\n \nInt\n \n-\n \nInt\n\n\narith\n \nx\n \ny\n \nz\n \n=\n \nx\n \n*\n \n(\ny\n \n+\n \nz\n)\n\n\n\n-- * Function appication happens one argument at a time (\ncurrying\n)\n\n\nadd\n \nx\n \ny\n \n=\n \nx\n \n+\n \ny\n\n\nfive\n \n=\n \nadd\n \n3\n \n2\n \n-- is the same as: (add 3) 2\n\n\nadd3\n \n=\n \nadd\n \n3\n  \n-- :: ???\n\n\n--   - What\ns another way to write add3? \n\n\n\n-- * All Haskell functions take one argument\n\n\n--   - Multi-argument functions just return funtions\n\n\n--   - E.g., the type of add with ()\ns added:\n\n\nadd\n \n::\n \nInteger\n \n-\n \n(\nInteger\n \n-\n \nInteger\n)\n\n\n--   - We usually ommit ()\ns since -\n is right-associative\n\n\n\nadd4Things\n \n::\n \nFloat\n \n-\n \n(\nFloat\n \n-\n \n(\nFloat\n \n-\n \n(\nFloat\n \n-\n \nFloat\n)))\n\n\nadd4Things\n \nx\n \ny\n \nz\n \nw\n \n=\n \nx\n \n+\n \ny\n \n+\n \nz\n \n+\n \nw\n \n+\n \n(\n1.0\n \n::\n \nFloat\n)\n\n\n\n-- # Tuples and lists\n\n\n\n-- * Haskell has basic support for tuples\n\n\n--   - Constructors: (), (,), (,,), ...\n\n\n\n--   - E.g., tuples\n\n\nunit\n   \n=\n \n()\n            \n::\n \n()\n \n-- kind of like void\n\n\ntuple2\n \n=\n \n(\n3\n,\n \nw\n)\n      \n::\n \n(\nInt\n,\n \nChar\n)\n\n\ntuple3\n \n=\n \n(\n3\n,\n \nw\n,\n \n3.3\n)\n \n::\n \n(\nInt\n,\n \nChar\n,\n \nDouble\n)\n\n\n\nfunAdd\n \n::\n \n(\nInt\n,\n \nInt\n)\n \n-\n \nInt\n\n\nfunAdd\n \n(\nx\n,\n \ny\n)\n \n=\n \nx\n \n+\n \ny\n\n\n\nfunAdd35\n \n=\n \nfunAdd\n \n(\n3\n,\n \n5\n)\n\n\n\n-- * Haskell has basic support for homogeneous lists\n\n\n--   - Constructors: (:) | []\n\n\nmyIntList\n \n=\n \n[\n1\n,\n2\n,\n3\n]\n \n::\n \n[\nInt\n]\n\n\n-- same as consing things:\n\n\nmyIntList\n \n=\n \n1\n:\n2\n:\n3\n:[]\n\n\n-- (:) :: Int -\n [Int] -\n [Int]\n\n\n-- (:) 3 [] == 3:[] == [3]\n\n\n\n-- * Cons (:) is used to add elements to the list; ++ can be used to\n\n\n-- concatenate lists:\n\n\nconcatenatedList\n \n=\n \n[\n1\n,\n2\n,\n3\n]\n \n++\n \n[\n4\n,\n5\n,\n6\n]\n\n\n\n-- * Empty lists\n\n\nmyEmptyBoolList\n \n::\n \n[\nBool\n]\n\n\nmyEmptyBoolList\n \n=\n \n[]\n\n\nmyEmptyCharList\n \n::\n \n[\nChar\n]\n\n\nmyEmptyCharList\n \n=\n \n[]\n\n\n\n-- * Haskell does not have support for heterogenous lists\n\n\n--   - E.g., myHeteroList = [1, \nw\n] :: ???\n\n\n\n-- # Abstract data types\n\n\n\n-- * The \ndata\n keyword declares user-defined data types\n\n\ndata\n \nPairT\n \n=\n \nPairC\n \nInt\n \nInt\n \n             \nderiving\n \nShow\n \n-- means you can print types\n\n\n--  - New type: PairT\n\n\n--  - Value/data constructor: PairC\n\n\n--  - A value of this type encapsulates two Int\ns\n\n\nmyPair\n \n::\n \nPairT\n\n\nmyPair\n \n=\n \nPairC\n \n3\n \n4\n\n\n\n-- * One type can have multiple constructors\n\n\ndata\n \nPoint\n \n=\n \nCartesian\n \nDouble\n \nDouble\n\n           \n|\n \nPolar\n \nDouble\n \nDouble\n\n           \nderiving\n \nShow\n\n\n\npoint1\n,\n \npoint2\n \n::\n \nPoint\n\n\npoint1\n \n=\n \nCartesian\n \n3.3\n \n2.2\n\n\npoint2\n \n=\n \nPolar\n \n0.1\n \n3.14\n\n\n\ndata\n \nColor\n \n=\n \nRed\n \n|\n \nGreen\n \n|\n \nBlue\n \n|\n \nIndigo\n \n|\n \nViolet\n \nderiving\n \nShow\n\n\nmyRed\n \n=\n \nRed\n \n::\n \nColor\n\n\n\n-- ## Using ADTs\n\n\n\n-- * Constructors are like functions, can partially apply:\n\n\n\nmyPair\n \n::\n \nInt\n \n-\n \nPairT\n\n\nmyPair\n \n=\n \nPairC\n \n3\n\n\n\n-- * Case expressions can be used to \nde-construct\n values with patterns\n\n\n\ngetX\n \n::\n \nPairT\n \n-\n \nInt\n\n\ngetX\n \npair\n \n=\n \ncase\n \npair\n \nof\n\n               \nPairC\n \nx\n \ny\n \n-\n \nx\n\n\n\n-- E.g., convert point to cartesian:\n\n\ntoCartesian\n \n::\n \nPoint\n \n-\n \nPoint\n\n\ntoCartesian\n \npoint\n \n=\n \ncase\n \npoint\n \nof\n\n                      \nPolar\n \nr\n \ntheta\n \n-\n \nCartesian\n \n(\nr\n \n*\n \ncos\n \ntheta\n)\n\n                                                 \n(\nr\n \n*\n \nsin\n \ntheta\n)\n\n                      \n-- Cartesian x y -\n Cartesian x y -- or, less verbose:\n\n                      \npt\n@\n(\nCartesian\n \n_\n \n_\n)\n \n-\n \npt\n\n\n\n-- We can define a tiny language with addition and multiplication:\n\n\ndata\n \nExpr\n \n=\n \nAddExpr\n \nExpr\n \nExpr\n\n          \n|\n \nMulExpr\n \nExpr\n \nExpr\n\n          \n|\n \nConstExpr\n \nInt\n\n          \nderiving\n \nShow\n\n\n\neval\n \n::\n \nExpr\n \n-\n \nInt\n\n\neval\n \n(\nConstExpr\n \nn\n)\n \n=\n \nn\n\n\neval\n \n(\nAddExpr\n \ne1\n \ne2\n)\n \n=\n \neval\n \ne1\n \n+\n \neval\n \ne2\n\n\neval\n \n(\nMulExpr\n \ne1\n \ne2\n)\n \n=\n \neval\n \ne1\n \n*\n \neval\n \ne2\n\n\n\n-- ## Pattern matching beyond case\n\n\n\n-- * Can use patterns instead of variables beyond case\n\n\n--   - E.g., when defining functions:\n\n\ntoCartesian\n \n::\n \nPoint\n \n-\n \nPoint\n\n\ntoCartesian\n \n(\nPolar\n \nr\n \ntheta\n)\n \n=\n \nCartesian\n \n(\nr\n \n*\n \ncos\n \ntheta\n)\n\n                                         \n(\nr\n \n*\n \nsin\n \ntheta\n)\n\n\ntoCartesian\n \nx\n \n=\n \nx\n\n\n\n--   - E.g., in a let block\n\n\ngetY\n \npair\n \n=\n \nlet\n \n(\nPairC\n \n_\n \ny\n)\n \n=\n \npair\n \nin\n \ny\n\n\n\n-- * The order of pattern matching matters\n\n\n--   - E.g., What happens if we swap order?\n\n\nfactorial\n \n0\n \n=\n \n1\n\n\nfactorial\n \nn\n \n=\n \nn\n \n*\n \n(\nfactorial\n \n(\nn\n-\n1\n))\n\n\n\n-- * You can alternatively guard definitions:\n\n\nfactorial\n \nn\n \n|\n \nisLT0\n \nn\n \n=\n \n1\n\n\nfactorial\n \nn\n \n|\n \notherwise\n \n=\n \nn\n \n*\n \n(\nfactorial\n \n(\nn\n-\n1\n))\n\n\n\n-- * Guards are just predicates\n\n\nisLT0\n \n::\n \nInt\n \n-\n \nBool\n\n\nisLT0\n \n=\n \n(\n=\n0\n)\n\n\n\n-- ## Recursive datatypes\n\n\n\n-- * Datatypes can be defined recursively\n\n\n--   - E.g., int list:\n\n\n\ndata\n \nIntList\n \n=\n \nINil\n \n|\n \nICons\n \nInt\n \nIntList\n\n             \nderiving\n \nShow\n   \n-- ^^^^^^^\n\n\n\nmyEmptyIntList\n \n=\n \nINil\n \n::\n \nIntList\n\n\n\nmyIntList\n \n=\n \nICons\n \n1\n \n(\nICons\n \n2\n \n(\nICons\n \n3\n \nmyEmptyIntList\n))\n \n::\n \nIntList\n\n\n\nsumOfIntList\n \n::\n \nIntList\n \n-\n \nInt\n\n\nsumOfIntList\n \nINil\n \n=\n \n0\n\n\nsumOfIntList\n \n(\nICons\n \nx\n \nxs\n)\n \n=\n \nx\n \n+\n \n(\nsumOfIntList\n \nxs\n)\n\n\n{- Solution:\n\n\nsumOfIntList INil = error \nEmpty list\n\n\nsumOfIntList (ICons x INil) = x\n\n\nsumOfIntList (ICons x xs) = x + sumOfIntList xs\n\n\n-}\n\n\n\nsix\n \n::\n \nBool\n\n\nsix\n \n=\n \nsumOfIntList\n \nmyIntList\n \n==\n \n6\n\n\n\n-- ## Polymorphic datatypes\n\n\n\n-- * I want a list of Char\ns or String\ns or Point\ns\n\n\n--   - Define separate datatype for each: crazy! We want re-usability!\n\n\n\ndata\n \nCharList\n \n=\n \nCNil\n \n|\n \nCCons\n \nChar\n \nCharList\n \nderiving\n \nShow\n\n\n\n-- * May want to have functions that work on any kind of lists\n\n\n--   - Solution: parametrized types\n\n\n-- * Types can have parameters (kind of like functions)\n\n\ndata\n \nList\n \na\n \n=\n \nNil\n \n|\n \nCons\n \na\n \n(\nList\n \na\n)\n \nderiving\n \nShow\n\n                  \n--     ^  ^^^^^^\n\n\n--   - Here, List itself takes an argument: type variable a.\n\n\n--   - Can use type variable a in constructor\n\n\n\n--   - Cons and Nil work on any types:\n\n\nmyIntList\n \n::\n \nList\n \nInt\n\n\nmyIntList\n \n=\n \nCons\n \n1\n \n(\nCons\n \n2\n \n(\nCons\n \n3\n \nNil\n))\n\n\n\nmyCharList\n \n::\n \nList\n \nChar\n\n\nmyCharList\n \n=\n \nCons\n \na\n \n(\nCons\n \nb\n \n(\nCons\n \nc\n \nNil\n))\n\n\n\nllength\n \n::\n \nList\n \na\n \n-\n \nInt\n\n\nllength\n \n=\n \nundefined\n\n\n{- Solution:\n\n\nllength Nil = 0\n\n\nllength (Cons x xs) = 1 + llength xs\n\n\n-}\n\n\n\nmyList\nlen\n \n::\n \nBool\n\n\nmyList\nlen\n \n=\n  \n3\n \n==\n \nllength\n \nmyIntList\n \n\n              \n3\n \n==\n \nllength\n \nmyCharList\n\n\n\n-- ## Polymorphic datatypes with multiple parameters\n\n\n\n-- * Can have multiple type variables\n\n\n\ndata\n \nEither\n \na\n \nb\n \n=\n \nLeft\n \na\n \n|\n \nRight\n \nb\n\n                \nderiving\n \nShow\n\n\n\nsafeDiv\n \n::\n \nInt\n \n-\n \nInt\n \n-\n \nEither\n \nString\n \nInt\n\n\nsafeDiv\n \n_\n \n0\n \n=\n \nmyErr\n\n\nsafeDiv\n \nx\n \ny\n \n=\n \nRight\n \n$\n \nx\n \n`\ndiv\n`\n \ny\n\n\n\n-- * What is the type of:\n\n\n--myErr :: ???\n\n\nmyErr\n \n=\n \nLeft\n \nYou can\nt divide by zero, silly.\n\n\n\n-- # Lazyness\n\n\n\n-- * Definitions of symbols evauated ony when needed\n\n\n--   -  E.g., safe division:\n\n\nsafeDiv\n \nx\n \ny\n \n=\n\n  \nlet\n \nq\n \n=\n \ndiv\n \nx\n \ny\n        \n-- safe as q never evaluated if y == 0\n\n  \nin\n \nif\n \ny\n \n==\n \n0\n \nthen\n \n0\n \nelse\n \nq\n\n\n\n-- * Infinite data structures\n\n\nposInts\n \n=\n \n[\n1\n..\n]\n \n::\n \n[\nInt\n]\n\n\n\n-- * Custom control \nprimitives\n\n\n--   - E.g., if:\n\n\nif\n \nb\n \nx\n \ny\n \n=\n \ncase\n \nb\n \nof\n\n              \nTrue\n \n-\n \nx\n\n              \n_\n    \n-\n \ny\n\n\n--   - E.g., loop forever:\n\n\nforever\n \nx\n \n=\n \nforever\n \nx\n\n\n--   - What doe the following mean?\n\n\nexampleF\n \n=\n \nif\n \nTrue\n \n3\n \n(\nforever\n \n4\n)\n\n\n\n-- ## Laziness FTW: undefined and error\n\n\n\n-- * Can leave things as undefined -- sometimes called bottom\n\n\n\nthisVarIsUndef\n \n=\n \nundefined\n\n\nsoIsThisVar\n    \n=\n \nerror\n \nleaving this undefined for now, fixme later\n\n\n\n-- * Because Haskell is lazy, it won\nt throw up unless you use them\n\n\n\n-- * Why might this be useful?\n\n\n\n-- * Note: This is not how you should raise exceptions in Haskell!\n\n\n\n\n-- # Bindings with where clauses\n\n\n\n-- * Recall that let x = ... in ... can be used to bind variable x within local scope\n\n\n\n-- * Let can be used whenever you need to create block scope; \nlet\ns are expressions\n\n\n\n-- * Sometimes you want more flexiblity; therein comes the \nwhere\n clauses:\n\n\n\ncmpSquare\n \nx\n \ny\n  \n|\n  \ny\n \n \nz\n    \n=\n  \nbigger :)\n\n               \n|\n  \ny\n \n==\n \nz\n   \n=\n  \nsame :|\n\n               \n|\n  \ny\n \n \nz\n    \n=\n  \nsmaller :(\n\n    \nwhere\n \nz\n \n=\n \nx\n*\nx\n\n\n\n-- * Note that z is in scope of the function there\n\n\n\n-- * General: where clause associated with function equations or case expressions", 
            "title": "Week 3"
        }, 
        {
            "location": "/lectures/week3/#lecture-slides", 
            "text": "Scope:  pdf ,  key ,  Haskell:  pdf ,  key ,", 
            "title": "Lecture slides"
        }, 
        {
            "location": "/lectures/week3/#recommended-reading", 
            "text": "Textbook: Chapter 7 on Scope,  Chapter 5  on Haskell.  Philip Guo's  JavaScript tutor", 
            "title": "Recommended reading"
        }, 
        {
            "location": "/lectures/week3/#external-sources", 
            "text": "If you have not worked with Haskell before, take some time to familiarize\nyourself with the basics of the language. The chapter above is a good start.\nBut there are many other sources to take advantage of, including:   Brent Yorgey's  Haskell Basics  lectures.  Learn You a Haskell for Great Good!  is also a good book to read through.  A history of Haskell: Being lazy with class  is a fantastic read, and there is a similarly engaging  talk .   A history of Haskell: Being lazy with class  is a fantastic read.   A Gentle Introduction to Haskell 98    The Haskell 2010 Language", 
            "title": "External sources"
        }, 
        {
            "location": "/lectures/week3/#source-code-used-in-class", 
            "text": "Below you'll find the source we used during lecture. You can run these with\nGHCi (e.g., from  Haskell Platform ).  module   Intro   where  import   Prelude   hiding   ( Either ( .. ))  -- # Definitions and bindings  -- * Haskell uses the = sign to declare symbol *bindings*:  x   =   2  -- * They are called variables, but they are not mutable boxes  --   * They are like JS s const (but on steroids)  -- x = 3  -- is this allowed?  -- *  let  introduces local bindings (new scope)  example0   =   let   x   =   44   -- this  shadows  above x \n                z   =   x   -   2 \n            in   z   *   2 \n            -- what is x here? A: 2, B: 44  -- * Variables are order-independent  a   =    if   y \n       then   a \n       else   b   -- we use the y defined below:  y   =   True  -- # Essence of programming in Haskell  -- * Everything is an expression  -- * Expressions evaluate to values  --    - What s the diff between expressions and values?  -- * Programming in Haskell: substituting equals by equals  --    - Lambda calculus for the win!  {-  example0 = let x = 44                 z = x - 2             in z * 2  --           = let z = 44 - 2             in z * 2  --           = (44 - 2) * 2  --           = 42 * 2  --           = 84  -}  -- # Every expression has a type  -- * E.g., intVal is a word-sized integer  intVal   ::   Int  intVal   =   31   *   ( 42   +   56 )  -- * E.g., ii is an Arbitrarily large integer  ii   ::   Integer  ii   =   31   *   ( 42   +   56000000   *   1000 )  -- * E.g., dbl is a double precision floating point  dbl   =   3   *   ( 4.2   +   5.6 )  -- * E.g., chr is a unicode character  chr   =   a   ::   Char  -- * E.g., str is a String = [Char]  str   =   w00t   ::   String  listOfInt   ::   [ Int ]  listOfInt   =   [ 1 , 2 , 3 ]  -- * E.g., truth is a Boolean  truth   =   True   ::   Bool  -- ## Some remarks about types  {-     * We didn t need to add type annotations: Haskell infers types       - Inspect types in GHCi with :t       - You should generally specify types anyway. Why?     * Is this the same thing as not having to specify types in JS?       - A: yes, B: no  -}  -- * Haskell doesn t do any implicit conversions  --   - What s the type of ii_x_dbl below:  --     ii_x_dbl = ii + dbl :: ???  --     - A: Double, B: Int, C: Type error  -- * Arithmetic operators + and * are overloaded (as are some other)  ii_add    =   ii   +   33      -- :: ?  dbl_add   =   dbl   +   33.0   -- :: ?  -- * We ll talk about overloading more in the upcoming classes  -- # Functions  -- * Functions have  arrow types  pos   ::   Integer   -   Bool  -- * Function arguments separated by space not (,) s  pos   x   =   x     0  -- * As in JS, you can just use lambdas instead:  gt   ::   Int   -   Int   -   Bool  gt   =   \\ x   y   -   x     y   -- \\xy.(x   y)  -- * Function application is like in lambda calculus:  is33pos   =   pos   33   -- True  -- * How you should NOT think about functions (or expressions):  --   - What does this function do?  -- * How you should think: what does this mean? Think math!  -- * In Haskell, f :: A -  B means:  --   - For every element x \u2208 A,  --      f(x) = y for some some element y \u2208 B   --      or f(x) diverges  -- ## Multi-argument functions  -- * Functions can take multiple arguments  arith   ::   Int   -   Int   -   Int   -   Int  arith   x   y   z   =   x   *   ( y   +   z )  -- * Function appication happens one argument at a time ( currying )  add   x   y   =   x   +   y  five   =   add   3   2   -- is the same as: (add 3) 2  add3   =   add   3    -- :: ???  --   - What s another way to write add3?   -- * All Haskell functions take one argument  --   - Multi-argument functions just return funtions  --   - E.g., the type of add with () s added:  add   ::   Integer   -   ( Integer   -   Integer )  --   - We usually ommit () s since -  is right-associative  add4Things   ::   Float   -   ( Float   -   ( Float   -   ( Float   -   Float )))  add4Things   x   y   z   w   =   x   +   y   +   z   +   w   +   ( 1.0   ::   Float )  -- # Tuples and lists  -- * Haskell has basic support for tuples  --   - Constructors: (), (,), (,,), ...  --   - E.g., tuples  unit     =   ()              ::   ()   -- kind of like void  tuple2   =   ( 3 ,   w )        ::   ( Int ,   Char )  tuple3   =   ( 3 ,   w ,   3.3 )   ::   ( Int ,   Char ,   Double )  funAdd   ::   ( Int ,   Int )   -   Int  funAdd   ( x ,   y )   =   x   +   y  funAdd35   =   funAdd   ( 3 ,   5 )  -- * Haskell has basic support for homogeneous lists  --   - Constructors: (:) | []  myIntList   =   [ 1 , 2 , 3 ]   ::   [ Int ]  -- same as consing things:  myIntList   =   1 : 2 : 3 :[]  -- (:) :: Int -  [Int] -  [Int]  -- (:) 3 [] == 3:[] == [3]  -- * Cons (:) is used to add elements to the list; ++ can be used to  -- concatenate lists:  concatenatedList   =   [ 1 , 2 , 3 ]   ++   [ 4 , 5 , 6 ]  -- * Empty lists  myEmptyBoolList   ::   [ Bool ]  myEmptyBoolList   =   []  myEmptyCharList   ::   [ Char ]  myEmptyCharList   =   []  -- * Haskell does not have support for heterogenous lists  --   - E.g., myHeteroList = [1,  w ] :: ???  -- # Abstract data types  -- * The  data  keyword declares user-defined data types  data   PairT   =   PairC   Int   Int  \n              deriving   Show   -- means you can print types  --  - New type: PairT  --  - Value/data constructor: PairC  --  - A value of this type encapsulates two Int s  myPair   ::   PairT  myPair   =   PairC   3   4  -- * One type can have multiple constructors  data   Point   =   Cartesian   Double   Double \n            |   Polar   Double   Double \n            deriving   Show  point1 ,   point2   ::   Point  point1   =   Cartesian   3.3   2.2  point2   =   Polar   0.1   3.14  data   Color   =   Red   |   Green   |   Blue   |   Indigo   |   Violet   deriving   Show  myRed   =   Red   ::   Color  -- ## Using ADTs  -- * Constructors are like functions, can partially apply:  myPair   ::   Int   -   PairT  myPair   =   PairC   3  -- * Case expressions can be used to  de-construct  values with patterns  getX   ::   PairT   -   Int  getX   pair   =   case   pair   of \n                PairC   x   y   -   x  -- E.g., convert point to cartesian:  toCartesian   ::   Point   -   Point  toCartesian   point   =   case   point   of \n                       Polar   r   theta   -   Cartesian   ( r   *   cos   theta ) \n                                                  ( r   *   sin   theta ) \n                       -- Cartesian x y -  Cartesian x y -- or, less verbose: \n                       pt @ ( Cartesian   _   _ )   -   pt  -- We can define a tiny language with addition and multiplication:  data   Expr   =   AddExpr   Expr   Expr \n           |   MulExpr   Expr   Expr \n           |   ConstExpr   Int \n           deriving   Show  eval   ::   Expr   -   Int  eval   ( ConstExpr   n )   =   n  eval   ( AddExpr   e1   e2 )   =   eval   e1   +   eval   e2  eval   ( MulExpr   e1   e2 )   =   eval   e1   *   eval   e2  -- ## Pattern matching beyond case  -- * Can use patterns instead of variables beyond case  --   - E.g., when defining functions:  toCartesian   ::   Point   -   Point  toCartesian   ( Polar   r   theta )   =   Cartesian   ( r   *   cos   theta ) \n                                          ( r   *   sin   theta )  toCartesian   x   =   x  --   - E.g., in a let block  getY   pair   =   let   ( PairC   _   y )   =   pair   in   y  -- * The order of pattern matching matters  --   - E.g., What happens if we swap order?  factorial   0   =   1  factorial   n   =   n   *   ( factorial   ( n - 1 ))  -- * You can alternatively guard definitions:  factorial   n   |   isLT0   n   =   1  factorial   n   |   otherwise   =   n   *   ( factorial   ( n - 1 ))  -- * Guards are just predicates  isLT0   ::   Int   -   Bool  isLT0   =   ( = 0 )  -- ## Recursive datatypes  -- * Datatypes can be defined recursively  --   - E.g., int list:  data   IntList   =   INil   |   ICons   Int   IntList \n              deriving   Show     -- ^^^^^^^  myEmptyIntList   =   INil   ::   IntList  myIntList   =   ICons   1   ( ICons   2   ( ICons   3   myEmptyIntList ))   ::   IntList  sumOfIntList   ::   IntList   -   Int  sumOfIntList   INil   =   0  sumOfIntList   ( ICons   x   xs )   =   x   +   ( sumOfIntList   xs )  {- Solution:  sumOfIntList INil = error  Empty list  sumOfIntList (ICons x INil) = x  sumOfIntList (ICons x xs) = x + sumOfIntList xs  -}  six   ::   Bool  six   =   sumOfIntList   myIntList   ==   6  -- ## Polymorphic datatypes  -- * I want a list of Char s or String s or Point s  --   - Define separate datatype for each: crazy! We want re-usability!  data   CharList   =   CNil   |   CCons   Char   CharList   deriving   Show  -- * May want to have functions that work on any kind of lists  --   - Solution: parametrized types  -- * Types can have parameters (kind of like functions)  data   List   a   =   Nil   |   Cons   a   ( List   a )   deriving   Show \n                   --     ^  ^^^^^^  --   - Here, List itself takes an argument: type variable a.  --   - Can use type variable a in constructor  --   - Cons and Nil work on any types:  myIntList   ::   List   Int  myIntList   =   Cons   1   ( Cons   2   ( Cons   3   Nil ))  myCharList   ::   List   Char  myCharList   =   Cons   a   ( Cons   b   ( Cons   c   Nil ))  llength   ::   List   a   -   Int  llength   =   undefined  {- Solution:  llength Nil = 0  llength (Cons x xs) = 1 + llength xs  -}  myList len   ::   Bool  myList len   =    3   ==   llength   myIntList   \n               3   ==   llength   myCharList  -- ## Polymorphic datatypes with multiple parameters  -- * Can have multiple type variables  data   Either   a   b   =   Left   a   |   Right   b \n                 deriving   Show  safeDiv   ::   Int   -   Int   -   Either   String   Int  safeDiv   _   0   =   myErr  safeDiv   x   y   =   Right   $   x   ` div `   y  -- * What is the type of:  --myErr :: ???  myErr   =   Left   You can t divide by zero, silly.  -- # Lazyness  -- * Definitions of symbols evauated ony when needed  --   -  E.g., safe division:  safeDiv   x   y   = \n   let   q   =   div   x   y          -- safe as q never evaluated if y == 0 \n   in   if   y   ==   0   then   0   else   q  -- * Infinite data structures  posInts   =   [ 1 .. ]   ::   [ Int ]  -- * Custom control  primitives  --   - E.g., if:  if   b   x   y   =   case   b   of \n               True   -   x \n               _      -   y  --   - E.g., loop forever:  forever   x   =   forever   x  --   - What doe the following mean?  exampleF   =   if   True   3   ( forever   4 )  -- ## Laziness FTW: undefined and error  -- * Can leave things as undefined -- sometimes called bottom  thisVarIsUndef   =   undefined  soIsThisVar      =   error   leaving this undefined for now, fixme later  -- * Because Haskell is lazy, it won t throw up unless you use them  -- * Why might this be useful?  -- * Note: This is not how you should raise exceptions in Haskell!  -- # Bindings with where clauses  -- * Recall that let x = ... in ... can be used to bind variable x within local scope  -- * Let can be used whenever you need to create block scope;  let s are expressions  -- * Sometimes you want more flexiblity; therein comes the  where  clauses:  cmpSquare   x   y    |    y     z      =    bigger :) \n                |    y   ==   z     =    same :| \n                |    y     z      =    smaller :( \n     where   z   =   x * x  -- * Note that z is in scope of the function there  -- * General: where clause associated with function equations or case expressions", 
            "title": "Source code used in class"
        }, 
        {
            "location": "/lectures/week4/", 
            "text": "Lecture slides\n\n\n\n\nType systems and type inference: \npdf\n, \nkey\n,\n\n\n\n\nRecommended reading\n\n\n\n\nTextbook: new \nChapter 6\n on types.\n\n\nType systems for programming languages\n by Didier R\u00e9my\n\n\n\n\nType tetris\n\n\nIn our parametricity explorations we've explored some problems that not only\nasked you to implement parametric functions, but do so in terms of other\nparametric functions. This can be quite tricky, but also fun. Below is a worked\nout example of the \nhog\n function from the homework using only the \n(.)\n\nfunction:\n\n\n--------------------------------------------------------------\n\n\n-- Simplified example:\n\n\n--------------------------------------------------------------\n\n\nfoo0\n \n::\n \n(\nb\n \n-\n \nc\n)\n \n-\n \n(\na\n \n-\n \nb\n)\n \n-\n \na\n \n-\n \nc\n\n\nfoo0\n \nf\n \ng\n \nx\n \n=\n \nf\n \n(\ng\n \nx\n)\n\n\n-- Can be rewritten with the function composition operator (.) as:\n\n\nfoo1\n \n::\n \n(\nb\n \n-\n \nc\n)\n \n-\n \n(\na\n \n-\n \nb\n)\n \n-\n \na\n \n-\n \nc\n\n\nfoo1\n \nf\n \ng\n \nx\n \n=\n \n(\nf\n \n.\n \ng\n)\n \nx\n\n\n-- We can get rid of the x (eta conversion):\n\n\nfoo2\n \n::\n \n(\nb\n \n-\n \nc\n)\n \n-\n \n(\na\n \n-\n \nb\n)\n \n-\n \na\n \n-\n \nc\n\n\nfoo2\n \nf\n \ng\n \n=\n \nf\n \n.\n \ng\n\n\n-- Let\ns rewrite it in prefix form now:\n\n\nfoo3\n \n::\n \n(\nb\n \n-\n \nc\n)\n \n-\n \n(\na\n \n-\n \nb\n)\n \n-\n \na\n \n-\n \nc\n\n\nfoo3\n \nf\n \ng\n \n=\n \n(\n.\n)\n \nf\n \ng\n\n\n-- Get rid of g (eta again):\n\n\nfoo4\n \n::\n \n(\nb\n \n-\n \nc\n)\n \n-\n \n(\na\n \n-\n \nb\n)\n \n-\n \na\n \n-\n \nc\n\n\nfoo4\n \nf\n \n=\n \n(\n.\n)\n \nf\n\n\n-- Get rid of f (eta again):\n\n\nfoo5\n \n::\n \n(\nb\n \n-\n \nc\n)\n \n-\n \n(\na\n \n-\n \nb\n)\n \n-\n \na\n \n-\n \nc\n\n\nfoo5\n \n=\n \n(\n.\n)\n\n\n\n--------------------------------------------------------------\n\n\n--------------------------------------------------------------\n\n\n\nhog\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \nb\n \n-\n \nc\n)\n \n-\n \na\n \n-\n \nb\n \n-\n \nd\n\n\nhog\n \n=\n \nundefined\n\n\n\n-- Let\ns write this with explicit arguments\n\n\nhog0\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \nb\n \n-\n \nc\n)\n \n-\n \na\n \n-\n \nb\n \n-\n \nd\n\n\nhog0\n \nfCD\n \nfABC\n \nvA\n \nvB\n \n=\n \nundefined\n\n\n\n-- Note that we want to produce a d at the end of the day\n\n\n-- What gives us a d? fCD when called with a c\n\n\n-- How do we get a c? Well fABC gives us c when called with an a and b\n\n\nhog1\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \nb\n \n-\n \nc\n)\n \n-\n \na\n \n-\n \nb\n \n-\n \nd\n\n\nhog1\n \nfCD\n \nfABC\n \nvA\n \nvB\n \n=\n \nfCD\n \n(\nfABC\n \nvA\n \nvB\n)\n\n\n\n-- Another way to look at the type is to write all the parantheses: How can you\n\n\n-- think of this? fABC is almost the thing you want to return. You only need to\n\n\n-- change that c into a d. And the fCD function can be used to do exacly that!\n\n\n\nhog2\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nc\n))\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nd\n))\n\n\nhog2\n \nfCD\n \nfABC\n \nvA\n \n=\n\n  \n(\n.\n)\n \nfCD\n  \n{- :: (c -\n d) -}\n\n      \n(\nfABC\n \nvA\n \n{- :: (b -\n c) -}\n)\n\n\n\n-- We can now get rid of the vA:\n\n\nhog3\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nc\n))\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nd\n))\n\n\nhog3\n \nfCD\n \nfABC\n \n=\n \n((\n.\n)\n \nfCD\n)\n \n.\n \nfABC\n\n\n\n-- To get rid of fABC, let\ns first rewrite it in prefix:\n\n\nhog4\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nc\n))\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nd\n))\n\n\nhog4\n \nfCD\n \nfABC\n \n=\n \n(\n.\n)\n \n((\n.\n)\n \nfCD\n)\n \nfABC\n\n\n\n-- Now you can just get rid of fABC (eta conversion):\n\n\nhog5\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nc\n))\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nd\n))\n\n\nhog5\n \nfCD\n \n=\n \n(\n.\n)\n \n((\n.\n)\n \nfCD\n)\n\n\n\n-- We can now rewrite hog5 by moving fCD to the outside (look at foo1, the (.)\n\n\n-- are just functions like f and g):\n\n\nhog6\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nc\n))\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nd\n))\n\n\nhog6\n \nfCD\n \n=\n \n((\n.\n)\n \n.\n \n(\n.\n))\n \nfCD\n\n\n\n-- Finally we can just get rid of fCD (eta) and redundant parantheses:\n\n\nhog7\n \n::\n \n(\nc\n \n-\n \nd\n)\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nc\n))\n \n-\n \n(\na\n \n-\n \n(\nb\n \n-\n \nd\n))\n\n\nhog7\n \n=\n \n(\n.\n)\n \n.\n \n(\n.\n)", 
            "title": "Week 4"
        }, 
        {
            "location": "/lectures/week4/#lecture-slides", 
            "text": "Type systems and type inference:  pdf ,  key ,", 
            "title": "Lecture slides"
        }, 
        {
            "location": "/lectures/week4/#recommended-reading", 
            "text": "Textbook: new  Chapter 6  on types.  Type systems for programming languages  by Didier R\u00e9my", 
            "title": "Recommended reading"
        }, 
        {
            "location": "/lectures/week4/#type-tetris", 
            "text": "In our parametricity explorations we've explored some problems that not only\nasked you to implement parametric functions, but do so in terms of other\nparametric functions. This can be quite tricky, but also fun. Below is a worked\nout example of the  hog  function from the homework using only the  (.) \nfunction:  --------------------------------------------------------------  -- Simplified example:  --------------------------------------------------------------  foo0   ::   ( b   -   c )   -   ( a   -   b )   -   a   -   c  foo0   f   g   x   =   f   ( g   x )  -- Can be rewritten with the function composition operator (.) as:  foo1   ::   ( b   -   c )   -   ( a   -   b )   -   a   -   c  foo1   f   g   x   =   ( f   .   g )   x  -- We can get rid of the x (eta conversion):  foo2   ::   ( b   -   c )   -   ( a   -   b )   -   a   -   c  foo2   f   g   =   f   .   g  -- Let s rewrite it in prefix form now:  foo3   ::   ( b   -   c )   -   ( a   -   b )   -   a   -   c  foo3   f   g   =   ( . )   f   g  -- Get rid of g (eta again):  foo4   ::   ( b   -   c )   -   ( a   -   b )   -   a   -   c  foo4   f   =   ( . )   f  -- Get rid of f (eta again):  foo5   ::   ( b   -   c )   -   ( a   -   b )   -   a   -   c  foo5   =   ( . )  --------------------------------------------------------------  --------------------------------------------------------------  hog   ::   ( c   -   d )   -   ( a   -   b   -   c )   -   a   -   b   -   d  hog   =   undefined  -- Let s write this with explicit arguments  hog0   ::   ( c   -   d )   -   ( a   -   b   -   c )   -   a   -   b   -   d  hog0   fCD   fABC   vA   vB   =   undefined  -- Note that we want to produce a d at the end of the day  -- What gives us a d? fCD when called with a c  -- How do we get a c? Well fABC gives us c when called with an a and b  hog1   ::   ( c   -   d )   -   ( a   -   b   -   c )   -   a   -   b   -   d  hog1   fCD   fABC   vA   vB   =   fCD   ( fABC   vA   vB )  -- Another way to look at the type is to write all the parantheses: How can you  -- think of this? fABC is almost the thing you want to return. You only need to  -- change that c into a d. And the fCD function can be used to do exacly that!  hog2   ::   ( c   -   d )   -   ( a   -   ( b   -   c ))   -   ( a   -   ( b   -   d ))  hog2   fCD   fABC   vA   = \n   ( . )   fCD    {- :: (c -  d) -} \n       ( fABC   vA   {- :: (b -  c) -} )  -- We can now get rid of the vA:  hog3   ::   ( c   -   d )   -   ( a   -   ( b   -   c ))   -   ( a   -   ( b   -   d ))  hog3   fCD   fABC   =   (( . )   fCD )   .   fABC  -- To get rid of fABC, let s first rewrite it in prefix:  hog4   ::   ( c   -   d )   -   ( a   -   ( b   -   c ))   -   ( a   -   ( b   -   d ))  hog4   fCD   fABC   =   ( . )   (( . )   fCD )   fABC  -- Now you can just get rid of fABC (eta conversion):  hog5   ::   ( c   -   d )   -   ( a   -   ( b   -   c ))   -   ( a   -   ( b   -   d ))  hog5   fCD   =   ( . )   (( . )   fCD )  -- We can now rewrite hog5 by moving fCD to the outside (look at foo1, the (.)  -- are just functions like f and g):  hog6   ::   ( c   -   d )   -   ( a   -   ( b   -   c ))   -   ( a   -   ( b   -   d ))  hog6   fCD   =   (( . )   .   ( . ))   fCD  -- Finally we can just get rid of fCD (eta) and redundant parantheses:  hog7   ::   ( c   -   d )   -   ( a   -   ( b   -   c ))   -   ( a   -   ( b   -   d ))  hog7   =   ( . )   .   ( . )", 
            "title": "Type tetris"
        }, 
        {
            "location": "/lectures/week5/", 
            "text": "Lecture slides\n\n\n\n\nType classes and type inference: \npdf\n, \nkey\n,\n\n\n\n\nRecommended reading\n\n\n\n\nTextbook: new \nChapter 7\n on type classes.\n\n\n\n\nCode snippets\n\n\nSimple example showing how to make \nTree\n dataype an instance of \nShow\n:\n\n\ndata\n \nTree\n \na\n \n=\n \nNode\n \n(\nTree\n \na\n)\n \n(\nTree\n \na\n)\n\n            \n|\n \nLeaf\n \na\n\n\n\ninstance\n \nShow\n \na\n \n=\n \nShow\n \n(\nTree\n \na\n)\n \nwhere\n\n \nshow\n \n(\nLeaf\n \na\n)\n \n=\n \nshow\n \na\n\n \nshow\n \n(\nNode\n \nlt\n \nrt\n)\n \n=\n \nshow\n \nlt\n \n++\n \n /\n\\\\\n \n \n++\n \nshow\n \nrt\n\n\n\ndata\n \nColor\n \n=\n \nRed\n \n|\n \nGreen\n \n|\n \nBlue\n \n|\n \nIndigo\n \n|\n \nViolet\n\n           \nderiving\n \nShow", 
            "title": "Week 5"
        }, 
        {
            "location": "/lectures/week5/#lecture-slides", 
            "text": "Type classes and type inference:  pdf ,  key ,", 
            "title": "Lecture slides"
        }, 
        {
            "location": "/lectures/week5/#recommended-reading", 
            "text": "Textbook: new  Chapter 7  on type classes.", 
            "title": "Recommended reading"
        }, 
        {
            "location": "/lectures/week5/#code-snippets", 
            "text": "Simple example showing how to make  Tree  dataype an instance of  Show :  data   Tree   a   =   Node   ( Tree   a )   ( Tree   a ) \n             |   Leaf   a  instance   Show   a   =   Show   ( Tree   a )   where \n  show   ( Leaf   a )   =   show   a \n  show   ( Node   lt   rt )   =   show   lt   ++    / \\\\     ++   show   rt  data   Color   =   Red   |   Green   |   Blue   |   Indigo   |   Violet \n            deriving   Show", 
            "title": "Code snippets"
        }, 
        {
            "location": "/lectures/week6/", 
            "text": "Lecture slides\n\n\n\n\nType classes, continued from \nWeek 5\n.\n\n\nObjects: \npdf\n, \nkey\n,\n\n\n\n\nRecommended reading\n\n\n\n\nType classes chapter from \nWeek 5\n.\n\n\nTextbook: Chapters 10, 11.\n\n\nObject-oriented programming: Some history, and challenges for the next fifty years\n by Black.\n\n\nThe Early History Of Smalltalk\n by Kay.", 
            "title": "Week 6"
        }, 
        {
            "location": "/lectures/week6/#lecture-slides", 
            "text": "Type classes, continued from  Week 5 .  Objects:  pdf ,  key ,", 
            "title": "Lecture slides"
        }, 
        {
            "location": "/lectures/week6/#recommended-reading", 
            "text": "Type classes chapter from  Week 5 .  Textbook: Chapters 10, 11.  Object-oriented programming: Some history, and challenges for the next fifty years  by Black.  The Early History Of Smalltalk  by Kay.", 
            "title": "Recommended reading"
        }, 
        {
            "location": "/discussions/week1/", 
            "text": "JavaScript fundamentals revisited by Purag Moumdjian\n\n\nBelow are the notes from the discussion section.\n\n\nThe \nglobal\n object\n\n\nIn Node.js, the \nglobal\n object contains functions (and lots of other\ninformation) exposed by the runtime environment.\n\n\nBy default, \nthis\n in the top-level scope of a node module refers to the module\nitself. When not in strict mode, \nthis\n inside a function is automatically\nassigned the \nglobal\n object.\n\n\n// global object\n\n\n\nconsole\n.\nlog\n(\nthis\n \n===\n \nglobal\n);\n \n// ??\n\n\n\n{\n\n  \nconsole\n.\nlog\n(\nthis\n \n===\n \nglobal\n);\n \n// ??\n\n\n}\n\n\n\nfunction\n \nf\n \n()\n \n{\n\n  \nconsole\n.\nlog\n(\nthis\n \n===\n \nglobal\n);\n\n\n}\n\n\n\nf\n();\n \n// ??\n\n\n\nnew\n \nf\n();\n \n// ??\n\n\n\n(\nfunction\n \n()\n \n{\n\n  \nuse strict\n;\n\n  \nconsole\n.\nlog\n(\nthis\n \n===\n \nglobal\n);\n \n// ??\n\n\n})();\n\n\n\n\n\n\nReceivers/the \nthis\n keyword\n\n\nWe can dynamically change the value of \nthis\n when executing a function which\nuses it. All functions in JavaScript have three methods which let us do this:\n\ncall\n, \napply\n, and \nbind\n.\n\n\ncall\n and \napply\n immediately invoke the function with the specified receiver\n(target object) and arguments. \nbind\n creates a new function with the receiver\n(and any provided arguments) \nbound\n to the specified values. This lets us\ncreate clones of functions where the \nthis\n keyword always refers to a specific\nobject (see \nswapObj2\n below).\n\n\nbind\n also lets us accomplish \npartial application\n of functions, meaning we\ncan create copies of functions with some (or all) of the arguments already\nfixed. We'll revisit this in detail throughout the quarter.\n\n\n// objects + this\n\n\n\nlet\n \nobj\n \n=\n \n{\n\n  \nx\n:\n \n1\n,\n\n  \ny\n:\n \n2\n,\n\n  \nswap\n:\n \nfunction\n \n()\n \n{\n\n    \nlet\n \ntemp\n \n=\n \nthis\n.\nx\n;\n\n    \nthis\n.\nx\n \n=\n \nthis\n.\ny\n;\n\n    \nthis\n.\ny\n \n=\n \ntemp\n;\n\n  \n}\n\n\n};\n\n\n\nconsole\n.\nlog\n(\nobj\n.\nx\n,\n \nobj\n.\ny\n);\n \n// ??\n\n\n\nobj\n.\nswap\n();\n\n\n\nconsole\n.\nlog\n(\nobj\n.\nx\n,\n \nobj\n.\ny\n);\n \n// ??\n\n\n\nlet\n \nobj2\n \n=\n \n{\n\n  \nx\n:\n \n3\n,\n\n  \ny\n:\n \n4\n\n\n}\n\n\n\nconsole\n.\nlog\n(\nobj2\n.\nx\n,\n \nobj2\n.\ny\n);\n \n// ??\n\n\n\nobj\n.\nswap\n.\ncall\n(\nobj2\n);\n\n\n\nconsole\n.\nlog\n(\nobj2\n.\nx\n,\n \nobj2\n.\ny\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\nobj\n.\nx\n,\n \nobj\n.\ny\n);\n \n// ??\n\n\n\nswapObj2\n \n=\n \nobj\n.\nswap\n.\nbind\n(\nobj2\n);\n\n\n\nswapObj2\n();\n\n\nconsole\n.\nlog\n(\nobj2\n.\nx\n,\n \nobj2\n.\ny\n);\n \n// ??\n\n\n\nswapObj2\n();\n\n\nconsole\n.\nlog\n(\nobj2\n.\nx\n,\n \nobj2\n.\ny\n);\n \n// ??\n\n\n\n// Also works with regular functions (not belonging to an object)...\n\n\nfunction\n \nf\n \n()\n \n{\n\n  \nconsole\n.\nlog\n(\nthis\n.\nx\n,\n \nthis\n.\ny\n);\n\n\n}\n\n\n\nf\n.\ncall\n(\nobj2\n);\n\n\nconsole\n.\nlog\n(\nobj2\n.\nx\n,\n \nobj2\n.\ny\n);\n \n// ??\n\n\n\n// And also works with arguments...\n\n\nfunction\n \ng\n \n(\narg1\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nthis\n.\nx\n,\n \nthis\n.\ny\n,\n \narg1\n);\n\n\n}\n\n\n\ng\n.\ncall\n(\nobj2\n,\n \nargument 1\n);\n \n// ?\n\n\n\n\n\n\nClasses/Function constructors\n\n\nBefore classes were native to JavaScript, we would use plain old functions to\nconstruct objects. These are called \nfunction constructors\n. When we invoke any\nfunction with the \nnew\n keyword (i.e. \nnew Car()\n), \nthis\n is automatically\nbound to a newly created object (whose prototype \n__proto__\n is \nCar.prototype\n),\nallowing us to specify instance data attached to \nthis\n inside a function\nconstructor.\n\n\nSince functions create a new scope in JavaScript, and since JavaScript\nfunctions are closures, we can create \"hidden\"/private fields and methods just\nby declaring local variables and functions. These are only visible in the scope\nof the function, and because functions are closures and capture the\nenvironment, these \"fields\" and \"methods\" can be accessed even after the object\nis created.\n\n\nOne caveat is that each instance of the object will have its own copy of every\nprivate method, and if you want a public method that uses a private method, each\nobject needs a copy of that, too -- the public method will have to share the\nscope of the private method.\n\n\nThis is not the way you want to manage private field, it's just an\nillustration. See \nthis blog\npost\n for a\ndiscussion.\n\n\n// classes + function constructors\n\n\n\nlet\n \nCar\n \n=\n \nfunction\n \n(\nmake\n,\n \nmodel\n)\n \n{\n\n  \nthis\n.\nmake\n \n=\n \nmake\n;\n\n  \nthis\n.\nmodel\n \n=\n \nmodel\n;\n\n\n};\n\n\n\nlet\n \ncar1\n \n=\n \nnew\n \nCar\n(\ntoyota\n,\n \ncamry\n);\n\n\n\nconsole\n.\nlog\n(\ncar1\n.\nmake\n,\n \ncar1\n.\nmodel\n);\n \n// ??\n\n\n\n// We can even make private fields!\n\n\nCar\n \n=\n \nfunction\n \n(\nmake\n,\n \nmodel\n,\n \nyear\n)\n \n{\n\n  \nlet\n \nprivate_year\n \n=\n \nyear\n;\n\n\n  \nthis\n.\nmake\n \n=\n \nmake\n;\n\n  \nthis\n.\nmodel\n \n=\n \nmodel\n;\n\n\n}\n\n\n\nlet\n \ncar2\n \n=\n \nnew\n \nCar\n(\nhonda\n,\n \ncivic\n,\n \n2018\n)\n\n\n\nconsole\n.\nlog\n(\ncar2\n.\nmake\n,\n \ncar2\n.\nmodel\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\ncar2\n.\nprivate_year\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\ncar2\n.\nyear\n);\n \n// ??\n\n\n\n// Private methods?\n\n\nCar\n \n=\n \nfunction\n \n(\nmake\n,\n \nmodel\n,\n \nyear\n)\n \n{\n\n  \nlet\n \nprivate_year\n \n=\n \nyear\n;\n\n\n  \nthis\n.\nmake\n \n=\n \nmake\n;\n\n  \nthis\n.\nmodel\n \n=\n \nmodel\n;\n\n\n  \nfunction\n \nprivate_getInternalLabel\n \n()\n \n{\n\n    \nreturn\n \n`\n${\nmake\n}\n@\n${\nmodel\n}\n`\n;\n\n  \n}\n\n\n  \nthis\n.\ntoString\n \n=\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \n`\n${\nprivate_getInternalLabel\n()\n}\n@\n${\nprivate_year\n}\n`\n\n  \n};\n\n\n}\n\n\n\nlet\n \ncar3\n \n=\n \nnew\n \nCar\n(\nford\n,\n \nedge\n,\n \n2018\n);\n\n\n\nconsole\n.\nlog\n(\ncar3\n.\nprivate_getInternalLabel\n());\n \n// ??\n\n\nconsole\n.\nlog\n(\ncar3\n.\ntoString\n());\n \n// ??\n\n\n\n\n\n\nHoisting\n\n\nJavaScript \nhoists\n \nvar\n declaration and \nfunction\n declarations and\ndefinitions to the top of the current scope. This behavior may or not be\ndesired, but if you want to avoid it, just use \nlet\n and \nconst\n to declare\nvariables, as they are not hoisted -- in other words, they create a new scope\nonly once they executed, and these scopes end as soon as the surrounding block\nends.\n\n\n// hoisting\n\n\n\n{\n\n  \nconsole\n.\nlog\n(\nundeclared\n);\n \n// ??\n\n\n}\n\n\n\n{\n\n  \nconsole\n.\nlog\n(\nlet_declared_later\n);\n \n// ??\n\n  \nlet\n \nlet_declared_later\n;\n\n\n}\n\n\n\n{\n\n  \nconsole\n.\nlog\n(\nvar_declared_later\n);\n \n// ??\n\n  \nvar\n \nvar_declared_later\n;\n\n\n}\n\n\n\n{\n\n  \nconsole\n.\nlog\n(\ndefined_later\n());\n \n// ??\n\n  \nfunction\n \ndefined_later\n \n()\n \n{\n\n    \nreturn\n \nyay!\n;\n\n  \n}\n\n\n}\n\n\n\n{\n\n  \nconsole\n.\nlog\n(\nlet_defined_later\n());\n \n// ??\n\n  \nlet\n \nlet_defined_later\n \n=\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nyay!\n;\n\n  \n};\n\n\n}\n\n\n\n\n\n\nFunctions/Callbacks/Arrow Notation\n\n\nBelow, we have a function constructor for \nCar\n, and in the constructor we\ncreate methods \ngetMake\n and \ngetModel\n which access the arguments of the\nfunction. We return the new object to the caller and the function's scope ends,\nbut subsequent calls to \ngetMake\n and \ngetModel\n will still have access to the\narguments from the function's scope due to closure.\n\n\nFor another example, see \nClosure\n\n\n// functions + closures\n\n\n\nfunction\n \nf\n \n()\n \n{\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\nconsole\n.\nlog\n(\ntypeof\n \nf\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\nf\n \ninstanceof\n \nObject\n);\n \n// ??\n\n\n\nconsole\n.\nlog\n(\nf\n.\ntoString\n());\n \n// ??\n\n\n\n// Back to function constructors\n\n\nlet\n \nCar\n \n=\n \nfunction\n \n(\nmake\n,\n \nmodel\n)\n \n{\n\n  \nthis\n.\ngetMake\n \n=\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nmake\n;\n\n  \n};\n\n\n  \nthis\n.\ngetModel\n \n=\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nmodel\n;\n\n  \n};\n\n\n}\n\n\n\nlet\n \ncar1\n \n=\n \nnew\n \nCar\n(\ntoyota\n,\n \ncamry\n);\n\n\n\nconsole\n.\nlog\n(\ncar1\n.\ngetMake\n(),\n \ncar1\n.\ngetModel\n());\n \n// ??\n\n\n\n// Arrow notation: more concise, especially with callbacks\n\n\nconst\n \ng\n \n=\n \n()\n \n=\n \n{\n\n  \nreturn\n \n0\n;\n\n\n};\n\n\n\nconsole\n.\nlog\n(\ng\n());\n \n// ??\n\n\n\nsetTimeout\n(()\n \n=\n \n{\n\n  \nconsole\n.\nlog\n(\ndone\n);\n\n\n},\n \n10\n);\n\n\n\n// More examples of this in 06.functional.js...\n\n\n\n\n\n\nList Manipulation a la Functional Programming in JavaScript\n\n\nmap\n, \nreduce\n (or \nfold\n), and \nfilter\n are three examples of list\nmanipulation functions. Recursion is the bread and butter of functional\nprogramming, and these functions are prime examples. JavaScript arrays natively\nsupport some of these behaviors, as seen below.\n\n\n// functional stuff!\n\n\n\nconst\n \narray\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n];\n\n\n\nlet\n \nnewArray\n \n=\n \narray\n.\nmap\n((\nx\n)\n \n=\n \nx\n \n+\n \n1\n);\n\n\nconsole\n.\nlog\n(\nnewArray\n);\n \n// ??\n\n\n\nnewArray\n \n=\n \narray\n.\nreduce\n((\naccum\n,\n \nx\n)\n \n=\n \naccum\n \n+\n \nx\n,\n \n0\n);\n\n\nconsole\n.\nlog\n(\nnewArray\n);\n \n// ??\n\n\n\nnewArray\n \n=\n \narray\n.\nfilter\n((\nx\n)\n \n=\n \nx\n \n=\n \n2\n);\n\n\nconsole\n.\nlog\n(\nnewArray\n);\n \n// ??\n\n\n\nnewArray\n \n=\n \narray\n.\nfilter\n((\nx\n)\n \n=\n \nx\n \n \n2\n);\n\n\nconsole\n.\nlog\n(\nnewArray\n);\n \n// ??\n\n\n\n\n\n\nClosure\n\n\nBelow are some classical examples of closures.\n\n\n// Closure example\n\n\n\n// #1\n\n\n{\n\n  \nvar\n \nfuncs\n \n=\n \n[];\n\n  \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n)\n \n{\n\n    \nfuncs\n.\npush\n(\nfunction\n \n()\n \n{\n\n      \nconsole\n.\nlog\n(\ni\n);\n\n    \n});\n\n  \n}\n\n  \nfuncs\n.\nforEach\n(\nfunction\n \n(\nfunc\n)\n \n{\n\n    \nfunc\n();\n\n  \n});\n\n\n}\n\n\n\n// #2\n\n\n{\n\n  \nlet\n \ni\n \n=\n \n5\n;\n\n\n  \nconst\n \nf\n \n=\n \n()\n \n=\n \nconsole\n.\nlog\n(\ni\n);\n\n\n  \nf\n();\n \n// ??\n\n\n  \ni\n \n=\n \n10\n;\n\n\n  \nf\n();\n \n// ??\n\n\n}\n\n\n\n// #3\n\n\n// How do we fix the problem in #1?\n\n\n{\n\n  \nlet\n \nfuncs\n \n=\n \n[];\n\n  \nfor\n \n(\nlet\n \ni\n \n=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n)\n \n{\n\n    \nfuncs\n.\npush\n(()\n \n=\n \nconsole\n.\nlog\n(\ni\n));\n\n  \n}\n\n  \nfuncs\n.\nforEach\n((\nfunc\n)\n \n=\n \nfunc\n());\n\n\n}\n\n\n\n// #4\n\n\n// How can we fix it without using let? (Also, how did we fix this before let?)\n\n\n{\n\n  \nvar\n \nfuncs\n \n=\n \n[];\n\n  \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n)\n \n{\n\n    \nfuncs\n.\npush\n((\nfunction\n \n(\nj\n)\n \n{\n\n      \nreturn\n \nfunction\n \n()\n \n{\n\n        \nconsole\n.\nlog\n(\nj\n);\n\n      \n}\n\n    \n})(\ni\n));\n\n  \n}\n\n  \nfuncs\n.\nforEach\n(\nfunction\n \n(\nfunc\n)\n \n{\n\n    \nfunc\n();\n\n  \n});\n\n\n  \n// or...\n\n  \nfuncs\n \n=\n \n[];\n\n  \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n)\n \n{\n\n    \nfuncs\n.\npush\n(\nfunction\n \n(\nj\n)\n \n{\n\n      \nconsole\n.\nlog\n(\nj\n);\n\n    \n}.\nbind\n(\nnull\n,\n \ni\n));\n\n  \n}\n\n  \nfuncs\n.\nforEach\n(\nfunction\n \n(\nfunc\n)\n \n{\n\n    \nfunc\n();\n\n  \n});\n\n\n}", 
            "title": "Week 1"
        }, 
        {
            "location": "/discussions/week1/#javascript-fundamentals-revisited-by-purag-moumdjian", 
            "text": "Below are the notes from the discussion section.", 
            "title": "JavaScript fundamentals revisited by Purag Moumdjian"
        }, 
        {
            "location": "/discussions/week1/#the-global-object", 
            "text": "In Node.js, the  global  object contains functions (and lots of other\ninformation) exposed by the runtime environment.  By default,  this  in the top-level scope of a node module refers to the module\nitself. When not in strict mode,  this  inside a function is automatically\nassigned the  global  object.  // global object  console . log ( this   ===   global );   // ??  { \n   console . log ( this   ===   global );   // ??  }  function   f   ()   { \n   console . log ( this   ===   global );  }  f ();   // ??  new   f ();   // ??  ( function   ()   { \n   use strict ; \n   console . log ( this   ===   global );   // ??  })();", 
            "title": "The global object"
        }, 
        {
            "location": "/discussions/week1/#receiversthe-this-keyword", 
            "text": "We can dynamically change the value of  this  when executing a function which\nuses it. All functions in JavaScript have three methods which let us do this: call ,  apply , and  bind .  call  and  apply  immediately invoke the function with the specified receiver\n(target object) and arguments.  bind  creates a new function with the receiver\n(and any provided arguments)  bound  to the specified values. This lets us\ncreate clones of functions where the  this  keyword always refers to a specific\nobject (see  swapObj2  below).  bind  also lets us accomplish  partial application  of functions, meaning we\ncan create copies of functions with some (or all) of the arguments already\nfixed. We'll revisit this in detail throughout the quarter.  // objects + this  let   obj   =   { \n   x :   1 , \n   y :   2 , \n   swap :   function   ()   { \n     let   temp   =   this . x ; \n     this . x   =   this . y ; \n     this . y   =   temp ; \n   }  };  console . log ( obj . x ,   obj . y );   // ??  obj . swap ();  console . log ( obj . x ,   obj . y );   // ??  let   obj2   =   { \n   x :   3 , \n   y :   4  }  console . log ( obj2 . x ,   obj2 . y );   // ??  obj . swap . call ( obj2 );  console . log ( obj2 . x ,   obj2 . y );   // ??  console . log ( obj . x ,   obj . y );   // ??  swapObj2   =   obj . swap . bind ( obj2 );  swapObj2 ();  console . log ( obj2 . x ,   obj2 . y );   // ??  swapObj2 ();  console . log ( obj2 . x ,   obj2 . y );   // ??  // Also works with regular functions (not belonging to an object)...  function   f   ()   { \n   console . log ( this . x ,   this . y );  }  f . call ( obj2 );  console . log ( obj2 . x ,   obj2 . y );   // ??  // And also works with arguments...  function   g   ( arg1 )   { \n   console . log ( this . x ,   this . y ,   arg1 );  }  g . call ( obj2 ,   argument 1 );   // ?", 
            "title": "Receivers/the this keyword"
        }, 
        {
            "location": "/discussions/week1/#classesfunction-constructors", 
            "text": "Before classes were native to JavaScript, we would use plain old functions to\nconstruct objects. These are called  function constructors . When we invoke any\nfunction with the  new  keyword (i.e.  new Car() ),  this  is automatically\nbound to a newly created object (whose prototype  __proto__  is  Car.prototype ),\nallowing us to specify instance data attached to  this  inside a function\nconstructor.  Since functions create a new scope in JavaScript, and since JavaScript\nfunctions are closures, we can create \"hidden\"/private fields and methods just\nby declaring local variables and functions. These are only visible in the scope\nof the function, and because functions are closures and capture the\nenvironment, these \"fields\" and \"methods\" can be accessed even after the object\nis created.  One caveat is that each instance of the object will have its own copy of every\nprivate method, and if you want a public method that uses a private method, each\nobject needs a copy of that, too -- the public method will have to share the\nscope of the private method.  This is not the way you want to manage private field, it's just an\nillustration. See  this blog\npost  for a\ndiscussion.  // classes + function constructors  let   Car   =   function   ( make ,   model )   { \n   this . make   =   make ; \n   this . model   =   model ;  };  let   car1   =   new   Car ( toyota ,   camry );  console . log ( car1 . make ,   car1 . model );   // ??  // We can even make private fields!  Car   =   function   ( make ,   model ,   year )   { \n   let   private_year   =   year ; \n\n   this . make   =   make ; \n   this . model   =   model ;  }  let   car2   =   new   Car ( honda ,   civic ,   2018 )  console . log ( car2 . make ,   car2 . model );   // ??  console . log ( car2 . private_year );   // ??  console . log ( car2 . year );   // ??  // Private methods?  Car   =   function   ( make ,   model ,   year )   { \n   let   private_year   =   year ; \n\n   this . make   =   make ; \n   this . model   =   model ; \n\n   function   private_getInternalLabel   ()   { \n     return   ` ${ make } @ ${ model } ` ; \n   } \n\n   this . toString   =   function   ()   { \n     return   ` ${ private_getInternalLabel () } @ ${ private_year } ` \n   };  }  let   car3   =   new   Car ( ford ,   edge ,   2018 );  console . log ( car3 . private_getInternalLabel ());   // ??  console . log ( car3 . toString ());   // ??", 
            "title": "Classes/Function constructors"
        }, 
        {
            "location": "/discussions/week1/#hoisting", 
            "text": "JavaScript  hoists   var  declaration and  function  declarations and\ndefinitions to the top of the current scope. This behavior may or not be\ndesired, but if you want to avoid it, just use  let  and  const  to declare\nvariables, as they are not hoisted -- in other words, they create a new scope\nonly once they executed, and these scopes end as soon as the surrounding block\nends.  // hoisting  { \n   console . log ( undeclared );   // ??  }  { \n   console . log ( let_declared_later );   // ?? \n   let   let_declared_later ;  }  { \n   console . log ( var_declared_later );   // ?? \n   var   var_declared_later ;  }  { \n   console . log ( defined_later ());   // ?? \n   function   defined_later   ()   { \n     return   yay! ; \n   }  }  { \n   console . log ( let_defined_later ());   // ?? \n   let   let_defined_later   =   function   ()   { \n     return   yay! ; \n   };  }", 
            "title": "Hoisting"
        }, 
        {
            "location": "/discussions/week1/#functionscallbacksarrow-notation", 
            "text": "Below, we have a function constructor for  Car , and in the constructor we\ncreate methods  getMake  and  getModel  which access the arguments of the\nfunction. We return the new object to the caller and the function's scope ends,\nbut subsequent calls to  getMake  and  getModel  will still have access to the\narguments from the function's scope due to closure.  For another example, see  Closure  // functions + closures  function   f   ()   { \n   return   0 ;  }  console . log ( typeof   f );   // ??  console . log ( f   instanceof   Object );   // ??  console . log ( f . toString ());   // ??  // Back to function constructors  let   Car   =   function   ( make ,   model )   { \n   this . getMake   =   function   ()   { \n     return   make ; \n   }; \n\n   this . getModel   =   function   ()   { \n     return   model ; \n   };  }  let   car1   =   new   Car ( toyota ,   camry );  console . log ( car1 . getMake (),   car1 . getModel ());   // ??  // Arrow notation: more concise, especially with callbacks  const   g   =   ()   =   { \n   return   0 ;  };  console . log ( g ());   // ??  setTimeout (()   =   { \n   console . log ( done );  },   10 );  // More examples of this in 06.functional.js...", 
            "title": "Functions/Callbacks/Arrow Notation"
        }, 
        {
            "location": "/discussions/week1/#list-manipulation-a-la-functional-programming-in-javascript", 
            "text": "map ,  reduce  (or  fold ), and  filter  are three examples of list\nmanipulation functions. Recursion is the bread and butter of functional\nprogramming, and these functions are prime examples. JavaScript arrays natively\nsupport some of these behaviors, as seen below.  // functional stuff!  const   array   =   [ 1 ,   2 ,   3 ];  let   newArray   =   array . map (( x )   =   x   +   1 );  console . log ( newArray );   // ??  newArray   =   array . reduce (( accum ,   x )   =   accum   +   x ,   0 );  console . log ( newArray );   // ??  newArray   =   array . filter (( x )   =   x   =   2 );  console . log ( newArray );   // ??  newArray   =   array . filter (( x )   =   x     2 );  console . log ( newArray );   // ??", 
            "title": "List Manipulation a la Functional Programming in JavaScript"
        }, 
        {
            "location": "/discussions/week1/#closure", 
            "text": "Below are some classical examples of closures.  // Closure example  // #1  { \n   var   funcs   =   []; \n   for   ( var   i   =   0 ;   i     10 ;   i ++ )   { \n     funcs . push ( function   ()   { \n       console . log ( i ); \n     }); \n   } \n   funcs . forEach ( function   ( func )   { \n     func (); \n   });  }  // #2  { \n   let   i   =   5 ; \n\n   const   f   =   ()   =   console . log ( i ); \n\n   f ();   // ?? \n\n   i   =   10 ; \n\n   f ();   // ??  }  // #3  // How do we fix the problem in #1?  { \n   let   funcs   =   []; \n   for   ( let   i   =   0 ;   i     10 ;   i ++ )   { \n     funcs . push (()   =   console . log ( i )); \n   } \n   funcs . forEach (( func )   =   func ());  }  // #4  // How can we fix it without using let? (Also, how did we fix this before let?)  { \n   var   funcs   =   []; \n   for   ( var   i   =   0 ;   i     10 ;   i ++ )   { \n     funcs . push (( function   ( j )   { \n       return   function   ()   { \n         console . log ( j ); \n       } \n     })( i )); \n   } \n   funcs . forEach ( function   ( func )   { \n     func (); \n   }); \n\n   // or... \n   funcs   =   []; \n   for   ( var   i   =   0 ;   i     10 ;   i ++ )   { \n     funcs . push ( function   ( j )   { \n       console . log ( j ); \n     }. bind ( null ,   i )); \n   } \n   funcs . forEach ( function   ( func )   { \n     func (); \n   });  }", 
            "title": "Closure"
        }, 
        {
            "location": "/discussions/week2/", 
            "text": "Lambda Calc Review and Practice by Nadah Feteih\n\n\nBelow are some notes taken from lecture and slides. We wont be posting\nthe solutions to the practice problems we went through in discussion, \nbut come to office hours if you have any questions. \n\n\nSyntax\n\n\ne ::= x | (e e) | (\u03bbx.e)\n\n\n\n\n\nVariables, applications, lambda abstractions \n\n\nFaking multi-argument functions.  Is \n\u03bbx.\u03bby.\u03bbz.e\n the same as \n\u03bbxyz.e\n? No, why not. See:\n\n\n(\nx\n,\ny\n,\nz\n)\n \n=\n \n{}\n \n/* same as: */\n\n\n(\nx\n)\n \n=\n \n(\ny\n)\n \n=\n \n(\nz\n)\n \n=\n \n{}\n \n/* ? */\n\n\n\n\n\n\nSyntax\n\n\nFunction applications are left associative\n\n\ne1 e2 e3 e4 = (((e1 e2) e3) e4)\n\n\n\n\n\nParenthesis have no meanings, you can add them as much as you want following the correct rules.\n(Applications are left associative and terms are bound as far right as possible)\n\n\nYou can only drop parenthesis if the meaning isn't ambiguous.\n\n\nSemantics\n\n\n\n\n\n\n(\u03bbx.(\u03bby.(x + y))) 4 5\n which arguments do we apply first? \n\n\n\n\n\n\nFree and bound variables \n\n\n\n\n\n\nCapture avoiding substitution \n\n\n\n\n\n\n...\ny[x := e] = y\n(e1 e2)[x := e] = e1[x := e] e2[x := e]\n(\u03bbx.e1)[x := e] = \u03bbx.e1\n...\n\n\n\n\n\n\n\nAlpha renaming\n\n\n\n\n\u03bbx.e = \u03bby.e[x :=y], y != FV(e)\n\n\n\n\n\n\n\nBeta reduction \n\n\n\n\n(\u03bbx.e1)e2 = e1[x := e2]\n\n\n\n\n\n\n\nEta reduction\n\n\n\n\n\u03bbx. e x = e , x != FV(e)\n\n\n\n\n\nEvaluation Order (CBV and CBN)\n\n\n\n\n\n\nDoes it matter which order you choose to simplify subexpressions IF it reduces to normal form?\n\n\n\n\n\n\nWhat does normal form mean? Can no longer beta reduce.\n\n\n\n\n\n\nSome terms cannot be reduced to normal form. For example,\n\n\n\n\n\n\n(\u03bbx.y)\u03a9\n ----\n y CBN \n ----\n (\u03bbx.y)\u03a9 CBV\n\n\n\n\n\nPractice Problems\n\n\n\n\nWhat doe the following produce?\n\n\n\n\nconst\n \nY\n \n=\n \nf\n \n=\n \n(\nx\n \n=\n \nf\n(\nx\n(\nx\n)))(\nx\n \n=\nf\n(\nx\n(\nx\n)))\n\n\nY\n(\nz\n \n=\n \n9\n)\n\n\n\n\n\n\n\n\n(\u03bbx.x) (\u03bby.x y z)\n - what are the free variables? \n\n\n\n\nReduce the following\n\n\n\n\n\n\n((\u03bbx.(x y))(\u03bbz.z))\n\n\n\n\n\n\n(\u03bbx.x)((\u03bby.y) z)\n\n\n\n\n\n\n(\u03bbf.\u03bbx.(f x)) \u03bby.y+1\n\n\n\n\n\n\n(\u03bbx.\u03bby.x y)(\u03bbz.z)\n\n\n\n\n\n\n((\u03bbf.(\u03bbx.f (f x)))(\u03bbx.x+1)) 4\n\n\n\n\n\n\n(\u03bbf.(\u03bbx.f(f x)))(\u03bby.y+x)\n\n\n\n\n\n\n(\u03bbx.y)((\u03bbx.x x)(\u03bby.y z))\n\n\n\n\n\n\n(\u03bbp.\u03bbq.\u03bbr.p q r)(\u03bbp.\u03bbq.p q r)\n\n\n\n\n\n\n((\u03bbf.((\u03bbg.((f f) g))(\u03bbh.(k h))))(\u03bbx.(\u03bby.y)))`\n\n\n\n\n\n\nEvaluation Strategies - Reduce with CBV \n CBN\n\n\n\n\n\n\n(\u03bbx.\u03bby.y x)(5 + 2)(\u03bbx.x+1)\n\n\n\n\n\n\n(\u03bbf.f 7)((\u03bbx.x x) \u03bby.y)", 
            "title": "Week 2"
        }, 
        {
            "location": "/discussions/week2/#lambda-calc-review-and-practice-by-nadah-feteih", 
            "text": "Below are some notes taken from lecture and slides. We wont be posting\nthe solutions to the practice problems we went through in discussion, \nbut come to office hours if you have any questions.", 
            "title": "Lambda Calc Review and Practice by Nadah Feteih"
        }, 
        {
            "location": "/discussions/week2/#syntax", 
            "text": "e ::= x | (e e) | (\u03bbx.e)  Variables, applications, lambda abstractions   Faking multi-argument functions.  Is  \u03bbx.\u03bby.\u03bbz.e  the same as  \u03bbxyz.e ? No, why not. See:  ( x , y , z )   =   {}   /* same as: */  ( x )   =   ( y )   =   ( z )   =   {}   /* ? */", 
            "title": "Syntax"
        }, 
        {
            "location": "/discussions/week2/#syntax_1", 
            "text": "Function applications are left associative  e1 e2 e3 e4 = (((e1 e2) e3) e4)  Parenthesis have no meanings, you can add them as much as you want following the correct rules.\n(Applications are left associative and terms are bound as far right as possible)  You can only drop parenthesis if the meaning isn't ambiguous.", 
            "title": "Syntax"
        }, 
        {
            "location": "/discussions/week2/#semantics", 
            "text": "(\u03bbx.(\u03bby.(x + y))) 4 5  which arguments do we apply first?     Free and bound variables     Capture avoiding substitution     ...\ny[x := e] = y\n(e1 e2)[x := e] = e1[x := e] e2[x := e]\n(\u03bbx.e1)[x := e] = \u03bbx.e1\n...   Alpha renaming   \u03bbx.e = \u03bby.e[x :=y], y != FV(e)   Beta reduction    (\u03bbx.e1)e2 = e1[x := e2]   Eta reduction   \u03bbx. e x = e , x != FV(e)", 
            "title": "Semantics"
        }, 
        {
            "location": "/discussions/week2/#evaluation-order-cbv-and-cbn", 
            "text": "Does it matter which order you choose to simplify subexpressions IF it reduces to normal form?    What does normal form mean? Can no longer beta reduce.    Some terms cannot be reduced to normal form. For example,    (\u03bbx.y)\u03a9\n ----  y CBN \n ----  (\u03bbx.y)\u03a9 CBV", 
            "title": "Evaluation Order (CBV and CBN)"
        }, 
        {
            "location": "/discussions/week2/#practice-problems", 
            "text": "What doe the following produce?   const   Y   =   f   =   ( x   =   f ( x ( x )))( x   = f ( x ( x )))  Y ( z   =   9 )    (\u03bbx.x) (\u03bby.x y z)  - what are the free variables?    Reduce the following    ((\u03bbx.(x y))(\u03bbz.z))    (\u03bbx.x)((\u03bby.y) z)    (\u03bbf.\u03bbx.(f x)) \u03bby.y+1    (\u03bbx.\u03bby.x y)(\u03bbz.z)    ((\u03bbf.(\u03bbx.f (f x)))(\u03bbx.x+1)) 4    (\u03bbf.(\u03bbx.f(f x)))(\u03bby.y+x)    (\u03bbx.y)((\u03bbx.x x)(\u03bby.y z))    (\u03bbp.\u03bbq.\u03bbr.p q r)(\u03bbp.\u03bbq.p q r)    ((\u03bbf.((\u03bbg.((f f) g))(\u03bbh.(k h))))(\u03bbx.(\u03bby.y)))`    Evaluation Strategies - Reduce with CBV   CBN    (\u03bbx.\u03bby.y x)(5 + 2)(\u03bbx.x+1)    (\u03bbf.f 7)((\u03bbx.x x) \u03bby.y)", 
            "title": "Practice Problems"
        }, 
        {
            "location": "/notes/js_nono/", 
            "text": "Below are code snippets that illustrate some of the flexible features of\nJavaScript and how they can introduce unexpected/unintuitive behavior. There\nare many more; see Appendix B of Crockford's \nJavaScript: The Good Parts\n.\nPlease note that there are useful, positive sides of most of these; every\nlanguage design/implementation decision is a trade-off.\n\n\nAutomatic semicolon insertion\n\n\nfunction\n \nf\n()\n \n{\n\n     \nreturn\n \n3\n;\n\n\n}\n\n\nfunction\n \ng\n()\n \n{\n\n     \nreturn\n\n       \n3\n;\n\n\n}\n\n\nconsole\n.\nlog\n(\nf\n());\n \n// ??\n\n\nconsole\n.\nlog\n(\ng\n());\n \n// ??\n\n\n\n\n\n\nEval\n\n\nJavaScript's \neval\n function can be used to load and execute new code at\nruntime. This is generally considered a bad/dangerous idea, but nevertheless\nuseful in some cases. Beyond security implications (mostly a concern in the\nbrowser since \neval\n can easily be leveraged to carry out \nXSS\nattacks\n), however the\nbehavior of \neval\n differs when you call it directly or indirectly. This\ndifference was introduced in the name of performance (arguably okay since you\nshould not be using \neval\n very much, but still not great.)\n\n\nglobal\n.\nx\n \n=\n \n33\n;\n\n\n{\n\n  \nconst\n \nx\n \n=\n \n44\n;\n\n  \nconst\n \nev\n \n=\n \neval\n;\n\n  \nconsole\n.\nlog\n(\neval\n(\nx\n));\n \n// ??\n\n  \nconsole\n.\nlog\n(\nev\n(\nx\n));\n \n// ??\n\n\n}\n\n\n\n\n\n\nImplicit casting\n\n\nSee the sarcastic \nWAT\n video.\n\n\nMonkeypatching\n\n\nBecause JavaScript lets you modify arbitrary objects and their prototypes,\nrunning untrusted code safely is extremely difficult to do. (If you're\ninterested in this, come talk to me; this is some of my research).\nSee some examples\n\nhere\n on global\nobject poisoning. Here is the simplest:\n\n\n// suppose add was exposed by a third-party library\n\n\nfunction\n \nadd\n(\nx\n,\n \ny\n)\n \n{\n\n  \n// Poison the Object prototype by redefining toString,\n\n  \n// which is called when objects are implicitly casted to\n\n  \n// strings. The modified function modifies the object (this), by\n\n  \n// setting name to \nmud\n;\n\n  \nObject\n.\nprototype\n.\ntoString\n \n=\n \nfunction\n \n()\n \n{\n\n    \nvar\n \nname\n \n=\n \nthis\n.\nname\n \n;\n\n    \nthis\n.\nname\n \n=\n \nmud\n;\n\n    \nreturn\n \nHA \n \n+\n \nname\n \n+\n \n.  IM STEALIN UR CODEZ!\n;\n\n  \n};\n\n  \nreturn\n \nx\n \n+\n \ny\n;\n\n\n}\n\n\n\nvar\n \no\n \n=\n \n{\n \nname\n:\n \nBingo\n \n};\n\n\nconsole\n.\nlog\n(\nadd\n(\n3\n,\n4\n));\n \n// calling add poisoned Object.prototype\n\n\nconsole\n.\nlog\n(\n \n+\n \no\n);\n\n\nconsole\n.\nlog\n(\nYour name is now \n \n+\n \no\n.\nname\n);", 
            "title": "JavaScript No No's"
        }, 
        {
            "location": "/notes/js_nono/#automatic-semicolon-insertion", 
            "text": "function   f ()   { \n      return   3 ;  }  function   g ()   { \n      return \n        3 ;  }  console . log ( f ());   // ??  console . log ( g ());   // ??", 
            "title": "Automatic semicolon insertion"
        }, 
        {
            "location": "/notes/js_nono/#eval", 
            "text": "JavaScript's  eval  function can be used to load and execute new code at\nruntime. This is generally considered a bad/dangerous idea, but nevertheless\nuseful in some cases. Beyond security implications (mostly a concern in the\nbrowser since  eval  can easily be leveraged to carry out  XSS\nattacks ), however the\nbehavior of  eval  differs when you call it directly or indirectly. This\ndifference was introduced in the name of performance (arguably okay since you\nshould not be using  eval  very much, but still not great.)  global . x   =   33 ;  { \n   const   x   =   44 ; \n   const   ev   =   eval ; \n   console . log ( eval ( x ));   // ?? \n   console . log ( ev ( x ));   // ??  }", 
            "title": "Eval"
        }, 
        {
            "location": "/notes/js_nono/#implicit-casting", 
            "text": "See the sarcastic  WAT  video.", 
            "title": "Implicit casting"
        }, 
        {
            "location": "/notes/js_nono/#monkeypatching", 
            "text": "Because JavaScript lets you modify arbitrary objects and their prototypes,\nrunning untrusted code safely is extremely difficult to do. (If you're\ninterested in this, come talk to me; this is some of my research).\nSee some examples here  on global\nobject poisoning. Here is the simplest:  // suppose add was exposed by a third-party library  function   add ( x ,   y )   { \n   // Poison the Object prototype by redefining toString, \n   // which is called when objects are implicitly casted to \n   // strings. The modified function modifies the object (this), by \n   // setting name to  mud ; \n   Object . prototype . toString   =   function   ()   { \n     var   name   =   this . name   ; \n     this . name   =   mud ; \n     return   HA    +   name   +   .  IM STEALIN UR CODEZ! ; \n   }; \n   return   x   +   y ;  }  var   o   =   {   name :   Bingo   };  console . log ( add ( 3 , 4 ));   // calling add poisoned Object.prototype  console . log (   +   o );  console . log ( Your name is now    +   o . name );", 
            "title": "Monkeypatching"
        }
    ]
}