{
    "docs": [
        {
            "location": "/", 
            "text": "This course will cover basic concepts and design trade-offs related to\nprogramming languages. The first half of the course focuses on functions,\ntypes, scope, storage management, exceptions, and continuations. The second\nhalf covers object-oriented features and concurrency. We will conclude with a\nfew special-topics in programming languages. The class also has a number of\nsmall labs where students get to implement some of the language features\ndiscussed in class.\n\n\n\n\nSection ID:\n 927504\n\n\nLectures:\n Tuesday and Thursday, 6:30-7:50PM in CENTR 115\n\n\nSection:\n Fridays, 5:00-5:50PM in CENTR 119\n\n\nStaff email:\n \n\n\nPiazza:\n \nhttps://piazza.com/ucsd/winter2018/cse130\n\n\nGradescope code:\n MV8JVW\n\n\n\n\nTextbook\n\n\nWe will occasionally be following John Mitchell's \nConcepts In Programming\nLanguages\n textbook and assigning reading from this book and various other\nonline resources and papers. Some of the book chapters have been revised, we\nwill be handing out PDFs of these chapters. Cheaper renting options for the book\nseem to be available online (e.g., on \nAmazon\n).\n\n\nIf you are serious about programming languages Benjamin Pierce's \nTypes and Programming\nLanguages\n is a must.\n\n\nCourse Staff\n\n\n\n\nInstructor:\n \nDeian Stefan\n\n\nTAs:\n Abdulrahman Alkhelaifi, Nadah Feteih, Purag Moumdjian, Kaiser Pister, and Sanjeev T Reddy", 
            "title": "About"
        }, 
        {
            "location": "/#textbook", 
            "text": "We will occasionally be following John Mitchell's  Concepts In Programming\nLanguages  textbook and assigning reading from this book and various other\nonline resources and papers. Some of the book chapters have been revised, we\nwill be handing out PDFs of these chapters. Cheaper renting options for the book\nseem to be available online (e.g., on  Amazon ).  If you are serious about programming languages Benjamin Pierce's  Types and Programming\nLanguages  is a must.", 
            "title": "Textbook"
        }, 
        {
            "location": "/#course-staff", 
            "text": "Instructor:   Deian Stefan  TAs:  Abdulrahman Alkhelaifi, Nadah Feteih, Purag Moumdjian, Kaiser Pister, and Sanjeev T Reddy", 
            "title": "Course Staff"
        }, 
        {
            "location": "/syllabus/", 
            "text": "Week of \n\n\nTuesday\n\n\nThursday\n\n\nFriday (section)\n\n\n\n\n\n\n\n\n\n\nJan 09 \n Jan 11\n\n\nJavaScript and high-order functions\n\n\nJavaScript and high-order functions (cont)\n\n\n\n\n\n\n\n\nJan 16 \n Jan 18\n\n\nLambda calculus\n\n\nLambda calculus (cont)\n\n\n\n\n\n\n\n\nJan 23 \n Jan 25\n\n\nScope, storage management, function implementation\n\n\nHaskell crash course\n\n\nHaskell crash course (cont)\n\n\n\n\n\n\nJan 30 \n Feb 01\n\n\nType polymorphism and type inference\n\n\nType polymorphism and type inference (cont)\n\n\nMidterm review\n\n\n\n\n\n\nFeb 06 \n Feb 08\n\n\nMidterm\n\n\nType classes\n\n\n\n\n\n\n\n\nFeb 13 \n Feb 15\n\n\nType classes (cont)\n\n\nObjects\n\n\n\n\n\n\n\n\nFeb 20 \n Feb 22\n\n\nObjects (cont)\n\n\nvtables, subtyping, inheritance\n\n\n\n\n\n\n\n\nFeb 27 \n Mar 01\n\n\nControl flow, continuations, monads\n\n\nControl flow, continuations, monads (cont)\n\n\n\n\n\n\n\n\nMar 06 \n Mar 08\n\n\nRust crash course\n\n\nConcurrency (cont)\n\n\nRust crash course (cont)\n\n\n\n\n\n\nMar 13 \n Mar 15\n\n\nConcurrency (cont)\n\n\nConcurrency (cont)\n\n\n\n\n\n\n\n\n\n\nTenative release dates for assignments:\n\n\n\n\nWritten homeworks:\n Jan 17, Jan 24, Jan 31, Feb 14, Feb 20\n\n\nProgramming labs:\n Jan 12, Jan 26, Feb 09, Feb 23, Mar 09", 
            "title": "Syllabus"
        }, 
        {
            "location": "/syllabus/#tenative-release-dates-for-assignments", 
            "text": "Written homeworks:  Jan 17, Jan 24, Jan 31, Feb 14, Feb 20  Programming labs:  Jan 12, Jan 26, Feb 09, Feb 23, Mar 09", 
            "title": "Tenative release dates for assignments:"
        }, 
        {
            "location": "/about/", 
            "text": "The course consists of lectures, written homeworks, and programming labs.  The\ngoal of the course is to \n(1)\n familiarize you with various modern\nprogramming language concepts and paradigms and \n(2)\n get you to think about\nand understand the design trade-offs and implementations of different language\nfeatures. We will use real-world languages (e.g., JavaScript, Haskell, C++, and\nRust) to explore the different concepts. But, we will not cover any one\nlanguage in full -- this course is not meant to make you a proficient\nprogrammer, learning how to proficiently program in any of these languages is a\ncourse in and of itself.\n\n\nGrading\n\n\n\n\n5% Participation in class and online\n\n\n35% Homeworks and programming labs\n\n\n25% Midterm exam\n\n\n35% Final exam\n\n\n\n\nParticipation/pre-lecture readings\n\n\nBefore each class there will be some assigned reading. You are expected to do\nthe reading and have at least a vague understanding of the concepts that will\nbe discussed in class. This will allow us to spend the lecture time to solidify\nyour understanding.  Asking and answering questions in class, on Piazza, or\nduring office hours counts towards your class participation. \n\n\nHomework and programming labs\n\n\nWe will have written homework assignments and programming labs.  Both are meant\nto both reinforce your knowledge of the concepts covered in lecture and get you\nto think about PL in more depth, beyond what is covered lecture (e.g., if you\nwere tasked with designing a new language).\n\n\nYou are expected to work on written assignments in groups of 3. All written\nhomework must be typeset and submitted as a PDF using the online submission\ntool.  All written assignments must be submitted as a group.  Homeworks will be\nreleased Wednesdays and will be due the following Friday night (10 days). If\nyou turn it in early -- the following Tuesday (7 days) -- you will\nreceive an additional 10% of your grade. There are no late days.\n\n\nYou are expected to work on the programming labs by yourself. You may discuss\nthe assignments with students from the course, in general, but not any specific\nsolution. Programming assignments will be released Fridays and will be due 2\nweeks later on Friday night. There are no late days.\n\n\nIf you consult anything (books, academic papers, internet resources, people not\nin your group) when working on the assignments, note this in your submission.\nWe encourage outside learning but expect you to not seek out specific details\nabout a solution -- anything submitted should be considered your own work.\nSimilarly, you are expected to not publish or otherwise share your solutions at\nany point (even after the class is over).\n\n\nIf you are unsure about what is allowed, please ask the course staff.\n\n\nWe will have a 5 written homeworks and 5 programming labs. They equally count\ntowards 35% of your grade.\n\n\nTentative release dates for assignments\n\n\nAll assignments and solutions will be posted on Piazza. All are to be turned in\nvia gradescope. We will be releasing them on the following dates:\n\n\n\n\nWritten homeworks: Jan 17, Jan 24, Jan 31, Feb 14, Feb 20\n\n\nProgramming labs: Jan 12, Jan 26, Feb 09, Feb 23, Mar 09\n\n\n\n\nExams\n\n\nThe midterm exam will be held on \nFebruary 6th\n, in class. The midterm is\n\nclosed-book\n, but you may use a double-sided cheat sheet (letter-size).\n\n\nThe final exam will be held on March 20th in \nTBA\n from 7:00PM-9:59PM. You\n\nmust\n take the exam at this time and location.  The final is\n\nclosed-book\n, but you may use 2 double-sided cheat sheets (letter-size).\n\n\nThe exams will make up 60% of your grade. Since the final is cumulative your\nmidterm grade will be calculated as:\n\n\nmidterm \n 0 ?  max(final, midterm) : 0\n\n\n\n\n\nThis means that (1) you basically get a second chance if you don't so well on\nthe midterm and (2) you must show up to both the midterm and the final.  If you\nneed to miss either exam because of a documented medical emergency, contact the\ninstructor immediately.\n\n\nAcademic integrity and student conduct\n\n\nBy taking this course, you implicitly agree to abide by the UCSD policies on \nIntegrity\nof Scholarship\n and \nStudent Conduct\n.\nUniversity rules on integrity of scholarship and code of conduct are taken\nseriously and will be enforced.", 
            "title": "Organization"
        }, 
        {
            "location": "/about/#grading", 
            "text": "5% Participation in class and online  35% Homeworks and programming labs  25% Midterm exam  35% Final exam", 
            "title": "Grading"
        }, 
        {
            "location": "/about/#participationpre-lecture-readings", 
            "text": "Before each class there will be some assigned reading. You are expected to do\nthe reading and have at least a vague understanding of the concepts that will\nbe discussed in class. This will allow us to spend the lecture time to solidify\nyour understanding.  Asking and answering questions in class, on Piazza, or\nduring office hours counts towards your class participation.", 
            "title": "Participation/pre-lecture readings"
        }, 
        {
            "location": "/about/#homework-and-programming-labs", 
            "text": "We will have written homework assignments and programming labs.  Both are meant\nto both reinforce your knowledge of the concepts covered in lecture and get you\nto think about PL in more depth, beyond what is covered lecture (e.g., if you\nwere tasked with designing a new language).  You are expected to work on written assignments in groups of 3. All written\nhomework must be typeset and submitted as a PDF using the online submission\ntool.  All written assignments must be submitted as a group.  Homeworks will be\nreleased Wednesdays and will be due the following Friday night (10 days). If\nyou turn it in early -- the following Tuesday (7 days) -- you will\nreceive an additional 10% of your grade. There are no late days.  You are expected to work on the programming labs by yourself. You may discuss\nthe assignments with students from the course, in general, but not any specific\nsolution. Programming assignments will be released Fridays and will be due 2\nweeks later on Friday night. There are no late days.  If you consult anything (books, academic papers, internet resources, people not\nin your group) when working on the assignments, note this in your submission.\nWe encourage outside learning but expect you to not seek out specific details\nabout a solution -- anything submitted should be considered your own work.\nSimilarly, you are expected to not publish or otherwise share your solutions at\nany point (even after the class is over).  If you are unsure about what is allowed, please ask the course staff.  We will have a 5 written homeworks and 5 programming labs. They equally count\ntowards 35% of your grade.", 
            "title": "Homework and programming labs"
        }, 
        {
            "location": "/about/#tentative-release-dates-for-assignments", 
            "text": "All assignments and solutions will be posted on Piazza. All are to be turned in\nvia gradescope. We will be releasing them on the following dates:   Written homeworks: Jan 17, Jan 24, Jan 31, Feb 14, Feb 20  Programming labs: Jan 12, Jan 26, Feb 09, Feb 23, Mar 09", 
            "title": "Tentative release dates for assignments"
        }, 
        {
            "location": "/about/#exams", 
            "text": "The midterm exam will be held on  February 6th , in class. The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size).  The final exam will be held on March 20th in  TBA  from 7:00PM-9:59PM. You must  take the exam at this time and location.  The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size).  The exams will make up 60% of your grade. Since the final is cumulative your\nmidterm grade will be calculated as:  midterm   0 ?  max(final, midterm) : 0  This means that (1) you basically get a second chance if you don't so well on\nthe midterm and (2) you must show up to both the midterm and the final.  If you\nneed to miss either exam because of a documented medical emergency, contact the\ninstructor immediately.", 
            "title": "Exams"
        }, 
        {
            "location": "/about/#academic-integrity-and-student-conduct", 
            "text": "By taking this course, you implicitly agree to abide by the UCSD policies on  Integrity\nof Scholarship  and  Student Conduct .\nUniversity rules on integrity of scholarship and code of conduct are taken\nseriously and will be enforced.", 
            "title": "Academic integrity and student conduct"
        }, 
        {
            "location": "/contact/", 
            "text": "For general information and questions, please post to the class\n\nPiazza\n.  It's very likely that\nother students will have the same question. We will post announcements on\nPiazza, so please make sure to sign up.  For urgent or personal matters, please\npost a private question or contact the course staff by email.\n\n\nCourse staff email address:\n \n\n\nInstructor\n\n\n\n\nName:\n \nDeian Stefan\n\n\nEmail:\n \n\n\nAddress:\n CSE 3126\n\n\nOffice Hours:\n TBA\n\n\n\n\nTeaching Assistants\n\n\n\n\nName:\n Kaiser Pister\n\n\nOffice hours:\n Monday at TBA in TBA\n\n\n\nName:\n Purag Moumdjian\n\n\nOffice hours:\n Tuesday at TBA in TBA\n\n\n\nName:\n Nadah Feteih\n\n\nOffice hours:\n Wednesday 1-2PM, CSE B260A\n\n\n\nName:\n Sanjeev T Reddy\n\n\nOffice hours:\n Thursday at TBA in TBA\n\n\n\nName:\n Abdulrahman Alkhelaifi\n\n\nOffice hours:\n Friday at TBA in TBA", 
            "title": "Contact information"
        }, 
        {
            "location": "/contact/#instructor", 
            "text": "Name:   Deian Stefan  Email:    Address:  CSE 3126  Office Hours:  TBA", 
            "title": "Instructor"
        }, 
        {
            "location": "/contact/#teaching-assistants", 
            "text": "Name:  Kaiser Pister  Office hours:  Monday at TBA in TBA  Name:  Purag Moumdjian  Office hours:  Tuesday at TBA in TBA  Name:  Nadah Feteih  Office hours:  Wednesday 1-2PM, CSE B260A  Name:  Sanjeev T Reddy  Office hours:  Thursday at TBA in TBA  Name:  Abdulrahman Alkhelaifi  Office hours:  Friday at TBA in TBA", 
            "title": "Teaching Assistants"
        }, 
        {
            "location": "/lectures/week1/", 
            "text": "Lecture slides and code\n\n\n\n\nIntroduction: \npdf\n, \nkey\n\n\nJavaScript in a Nutshell: \npdf\n, \nkey\n\n\n\n\nRecommended reading\n\n\nIf you have not worked with JavaScript before, take some time to familiarize\nyourself with the basics of the language, as most of the labs in this class\nwill be in JavaScript.\n\n\nWe recommend the \nMozilla Developer Network's JavaScript\nGuide\n, but\nthere are many other tutorials on the Internet.\n\n\nDave Herman's \nEffective JavaScript\n is very good\nreference that covers a lot of the JavaScript intricacies.  You will not need\nthis for the class, but if you end up writing JavaScript code in the outside\nworld, this book is must-read.\n\n\nAdditional resources/reading for the curious\n\n\n\n\nBlock\n  bindings\n\n  and the difference between \nvar\n, \nlet\n, and \nconst\n.\n\n\nWhy a language like JavaScript took over the world? Not that uncommon, see\n  \nThe Rise of \"Worse is\n  Better\"\n.\n\n\nClosures\n\n  explained; see, especially the creating closures in a loop section.\n\n\nPrivate properties in (modern) JavaScript\n; we will revisit the idea of private properties (encapsulation) later in the course.\n\n\nShort intro to memory management for\n  JavaScript\n.\n\n\nES6 In Depth\n contains\n  more information on the more recent features introduced to JavaScript.\n\n\nArrow functions\n.\n\n\nJavaScript No-No's\n.\n\n\n\n\nSource code used in class\n\n\nBelow you'll find the source files we used during lecture. You can run these\nwith \nNode.js\n.\n\n\nScoping\n\n\nBlock scoping in modern JS:\n\n\nfunction\n \nhello\n(\nx\n)\n \n{\n\n  \nconsole\n.\nlog\n(\n`A: x = \n${\nx\n}\n`\n);\n \n// 42\n\n  \n{\n\n    \nlet\n \nx\n \n=\n \n45\n;\n\n    \nconsole\n.\nlog\n(\n`B: x = \n${\nx\n}\n`\n);\n \n// 45\n\n  \n}\n\n  \n{\n\n    \nconsole\n.\nlog\n(\n`C: x = \n${\nx\n}\n`\n);\n \n// 42\n\n  \n}\n\n\n}\n\n\n\nhello\n(\n42\n);\n\n\n\n\n\n\nFunction (but not block) scoping for \nvar\ns:\n\n\nfunction\n \nhello\n(\nx\n)\n \n{\n\n  \nconsole\n.\nlog\n(\n`A: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n{\n\n    \nvar\n \nx\n \n=\n \n45\n;\n\n    \nconsole\n.\nlog\n(\n`B: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n}\n\n  \n{\n\n    \nconsole\n.\nlog\n(\n`C: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n}\n\n\n}\n\n\n\nhello\n(\n42\n);\n\n\n\n\n\n\nMimicking block scoping with functions:\n\n\nfunction\n \nhello\n(\nx\n)\n \n{\n\n  \nconsole\n.\nlog\n(\n`A: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n(\nfunction\n \n()\n \n{\n\n    \nvar\n \nx\n \n=\n \n45\n;\n\n    \nconsole\n.\nlog\n(\n`B: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n})();\n\n  \n(\nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\n`C: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n})();\n\n\n}\n\n\n\nhello\n(\n42\n);\n\n\n\n\n\n\nNow, with arrow functions:\n\n\nfunction\n \nhello\n(\nx\n)\n \n{\n\n  \nconsole\n.\nlog\n(\n`A: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n(\nfunction\n \n()\n \n{\n\n    \nvar\n \nx\n \n=\n \n45\n;\n\n    \nconsole\n.\nlog\n(\n`B: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n})();\n\n  \n(()\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\n`C: x = \n${\nx\n}\n`\n);\n \n// ??\n\n  \n})();\n\n\n}\n\n\n\nhello\n(\n42\n);\n\n\n\n\n\n\nPerformance\n\n\nWithout high-order functions, we'd perform reads and write synchronously:\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nconst\n \nr1\n \n=\n \nfs\n.\nreadFileSync\n(\n./perf-sync.js\n,\n \nutf8\n);\n \n// blocks until read is done\n\n\nprocessFile\n(\nperf-sync.js\n,\n \nr1\n);\n \n// blocks until processing (write) is done\n\n\nconst\n \nr2\n \n=\n \nfs\n.\nreadFileSync\n(\n./perf-async.js\n,\n \nutf8\n);\n \n// etc.\n\n\nprocessFile\n(\nperf-async.js\n,\n \nr2\n);\n\n\n\n// note that you can declare a function after the point it\ns used. Hoisting\n\n\n// essentially moves it to the top.\n\n\nfunction\n \nprocessFile\n(\nfname\n,\n \nstr\n)\n \n{\n\n  \nfs\n.\nwriteFileSync\n(\n`/tmp/\n${\nfname\n}\n`\n,\n \nstr\n);\n\n  \nconsole\n.\nlog\n(\n`DONE writing /tmp/\n${\nfname\n}\n`\n);\n\n\n}\n\n\n\n\n\n\nPassing (callback) functions as arguments allows the runtime system to call our function whenever it's ready. This allows it to perform IO concurrently and more efficiently:\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nfs\n.\nreadFile\n(\n./perf-sync.js\n,\n \nutf8\n,\n \ncb1\n);\n \n// returns immediately, cb1 is queued on the event loop and called later when actual file read is done\n\n\nfs\n.\nreadFile\n(\n./perf-async.js\n,\n \nutf8\n,\n \ncb2\n);\n \n// returns immediately, \n \n\n\n\nfunction\n \nprocessFile\n(\nfname\n,\n \nstr\n)\n \n{\n\n  \nfs\n.\nwriteFileSync\n(\n`/tmp/\n${\nfname\n}\n`\n,\n \nstr\n);\n\n  \nconsole\n.\nlog\n(\n`DONE writing /tmp/\n${\nfname\n}\n`\n);\n\n\n}\n\n\n\nfunction\n \ncb1\n(\nerr\n,\n \nstr\n)\n \n{\n\n  \n// line cb1.1\n\n  \nprocessFile\n(\nperf-sync.js\n,\n \nstr\n);\n\n\n}\n\n\n\nfunction\n \ncb2\n(\nerr\n,\n \nstr\n)\n \n{\n\n  \n//line cb2.1\n\n  \nprocessFile\n(\nperf-async.js\n,\n \nstr\n);\n\n\n}\n\n\n\nCan\n \ncb2\n \nexecute\n \nbefore\n \ncb1\n?\n\n\nA\n:\n \nyes\n,\n \nB\n:\n \nno\n\n\n\n\n\n\nOnce we can return functions we can also express our code more compactly too:\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nfs\n.\nreadFile\n(\n./perf-sync.js\n,\n \nutf8\n,\n \nprocessFile\n(\nperf-sync.js\n));\n\n\nfs\n.\nreadFile\n(\n./perf-async.js\n,\n \nutf8\n,\n \nprocessFile\n(\nperf-async.js\n));\n\n\n\nfunction\n \nprocessFile\n(\nfname\n)\n \n{\n\n  \nreturn\n \n(\nerr\n,\n \nstr\n)\n \n=\n \n{\n\n    \nfs\n.\nwriteFileSync\n(\n`/tmp/\n${\nfname\n}\n`\n,\n \nstr\n);\n\n    \nconsole\n.\nlog\n(\n`DONE writing /tmp/\n${\nfname\n}\n`\n);\n\n  \n};\n\n\n}\n\n\n\n\n\n\nAnd, slightly cleaner:\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nreadAndProcessFile\n(\nperf-sync.js\n);\n\n\nreadAndProcessFile\n(\nperf-async.js\n);\n\n\n\nfunction\n \nreadAndProcessFile\n(\nname\n)\n \n{\n\n  \nreturn\n \nfs\n.\nreadFile\n(\n`./\n${\nname\n}\n`\n,\n \nutf8\n,\n \nprocessFile\n(\nname\n));\n\n\n}\n\n\n\nfunction\n \nprocessFile\n(\nfname\n)\n \n{\n\n  \nreturn\n \n(\nerr\n,\n \nstr\n)\n \n=\n \n{\n\n    \nfs\n.\nwriteFileSync\n(\n`/tmp/\n${\nfname\n}\n`\n,\n \nstr\n);\n\n    \nconsole\n.\nlog\n(\n`DONE writing /tmp/\n${\nfname\n}\n`\n);\n\n  \n};\n\n\n}\n\n\n\n\n\n\nExpressiveness\n\n\nHigh-order functions enables expressiveness:\n\n\nconst\n \nlist\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n];\n\n\n\nconsole\n.\nlog\n(\nfilter\n(\nlist\n,\n \nfunction\n \n(\nel\n)\n \n{\n \n  \nreturn\n \nel\n \n \n2\n;\n\n\n}));\n \n// ??\n\n\n\nconsole\n.\nlog\n(\nmap\n(\nlist\n,\n \nel\n \n=\n \n{\n \n  \nreturn\n \nel\n \n+\n \n42\n;\n\n\n}));\n \n// ??\n\n\n\n\nfunction\n \nfilter\n(\nlist\n,\n \npred\n)\n \n{\n\n  \nconst\n \ndup\n \n=\n \n[];\n\n  \nfor\n \n(\nlet\n \ni\n \n=\n \n0\n;\n \ni\n \n \nlist\n.\nlength\n;\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\npred\n(\nlist\n[\ni\n]))\n \n{\n\n      \ndup\n.\npush\n(\nlist\n[\ni\n]);\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ndup\n;\n\n\n}\n\n\n\nfunction\n \nmap\n(\nlist\n,\n \nf\n)\n \n{\n\n  \nconst\n \ndup\n \n=\n \n[];\n\n  \nfor\n \n(\nlet\n \ni\n \n=\n \nlist\n.\nlength\n-\n1\n;\n \ni\n \n=\n \n0\n;\n \ni\n--\n)\n \n{\n\n    \ndup\n.\nunshift\n(\nf\n(\nlist\n[\ni\n]));\n\n  \n}\n\n  \nreturn\n \ndup\n;\n\n\n}\n\n\n\n\n\n\nIt also can enable more efficient code:\n\n\nconst\n \nlist\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n];\n\n\n\nconst\n \nadd42\n \n=\n \n(\nel\n)\n \n=\n \n{\n\n  \nreturn\n \nel\n \n+\n \n42\n;\n\n\n};\n\n\n\nfunction\n \nmul1337\n \n(\nel\n)\n \n{\n\n  \nreturn\n \nel\n \n*\n \n1337\n;\n\n\n}\n\n\n\nconsole\n.\nlog\n(\nmap\n(\nmap\n(\nlist\n,\n \nadd42\n),\n \nmul1337\n));\n\n\nconsole\n.\nlog\n(\nmap\n(\nlist\n,\n \ncompose\n(\nmul1337\n,\n \nadd42\n)));\n\n\n\nfunction\n \ncompose\n \n(\nf\n,\n \ng\n)\n \n{\n\n  \nreturn\n \n(\nx\n)\n \n=\n \n{\n \n    \nreturn\n \nf\n(\ng\n(\nx\n));\n\n  \n}\n\n\n}\n\n\n\nfunction\n \nmap\n(\nlist\n,\n \nf\n)\n \n{\n\n  \nconst\n \ndup\n \n=\n \n[];\n\n  \nfor\n \n(\nlet\n \ni\n \n=\n \nlist\n.\nlength\n-\n1\n;\n \ni\n \n=\n \n0\n;\n \ni\n--\n)\n \n{\n\n    \ndup\n.\nunshift\n(\nf\n(\nlist\n[\ni\n]));\n\n  \n}\n\n  \nreturn\n \ndup\n;\n\n\n}\n\n\n\n\n\n\nAbstraction\n\n\nWe can also use functions to implement module systems.\n\n\nConsider a simple module in Node.js:\n\n\nconst\n \nsecret\n \n=\n \ncse130 is fun!\n;\n \n// scoped to this function, hidden to outside world\n\n\nexports\n.\nmyVar\n \n=\n \n42\n;\n\n\nexports\n.\nmyFunc\n \n=\n \nfunction\n \n(\nx\n)\n \n{\n\n  \nif\n \n(\nx\n \n===\n \nsecret\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nyes!\n);\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nguess again!\n);\n\n  \n}\n\n\n};\n\n\n\n\n\n\nThis module can be loaded with \nrequire\n, which is (very) roughly implemented\nas follows:\n\n\n// using node\ns requie:\n\n\n{\n\n  \nconst\n \nmod\n \n=\n \nrequire\n(\n./module-node.js\n);\n\n\n  \nconsole\n.\nlog\n(\nmod\n.\nmyVar\n);\n \n// ??\n\n  \nmod\n.\nmyFunc\n(\nwhat?\n);\n \n// ??\n\n  \nmod\n.\nmyFunc\n(\ncse130 is fun!\n);\n \n// ??\n\n\n}\n\n\n\n// using our fake require:\n\n\n{\n\n  \nconst\n \nmod\n \n=\n \nrequireMyModule\n();\n\n\n  \nconsole\n.\nlog\n(\nmod\n.\nmyVar\n);\n \n// ??\n\n  \nmod\n.\nmyFunc\n(\nwhat?\n);\n \n// ??\n\n  \nmod\n.\nmyFunc\n(\ncse130 is fun!\n);\n \n// ??\n\n\n}\n\n\n\nfunction\n \nmyModule\n(\nexports\n)\n \n{\n\n  \n// same code as module-node.js:\n\n  \nconst\n \nsecret\n \n=\n \ncse130 is fun!\n;\n \n// scoped to this function, hidden to outside world\n\n  \nexports\n.\nmyVar\n \n=\n \n42\n;\n\n  \nexports\n.\nmyFunc\n \n=\n \nfunction\n \n(\nx\n)\n \n{\n\n    \nif\n \n(\nx\n \n===\n \nsecret\n)\n \n{\n\n      \nconsole\n.\nlog\n(\nyes!\n);\n\n    \n}\n \nelse\n \n{\n\n      \nconsole\n.\nlog\n(\nguess again!\n);\n\n    \n}\n\n  \n};\n\n\n}\n\n\n\nfunction\n \nrequireMyModule\n()\n \n{\n\n  \n// create new object that will be populated by the module\n\n  \nconst\n \nexports\n \n=\n \n{};\n\n  \nmyModule\n(\nexports\n);\n\n  \nreturn\n \nexports\n;\n\n\n}\n\n\n\n\n\n\nObjects\n\n\nWe'll be looking at objects later in the class. Objects can be expressed\nad-hoc, using object literal notation:\n\n\nconst\n \nobj\n \n=\n \n{\n\n  \nx-w00t\n:\n \n10\n,\n\n  \nx\n:\n \n1337\n,\n\n  \nf\n:\n \nfunction\n \n(\ny\n)\n \n{\n\n    \nthis\n.\nx\n++\n;\n\n    \nreturn\n \nthis\n.\nx\n \n+\n \ny\n;\n\n  \n}\n\n\n};\n\n\n\nconsole\n.\nlog\n(\nobj\n.\nx\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\nobj\n.\nf\n(\n3\n));\n \n// ??\n\n\nconsole\n.\nlog\n(\nobj\n[\nx\n]);\n \n// ??\n\n\nconsole\n.\nlog\n(\nobj\n[\nx-w00t\n])\n \n// ??\n\n\n\n\n\n\nBut we can (again) use functions to construct objects:\n\n\nfunction\n \nCar\n(\nmake\n,\n \nmodel\n)\n \n{\n\n  \nthis\n.\nmake\n \n=\n \nmake\n;\n\n  \nthis\n.\nmodel\n \n=\n \nmodel\n;\n\n  \nthis\n.\ntoString\n \n=\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \n`\n${\nthis\n.\nmake\n}\n@\n${\nthis\n.\nmodel\n}\n`\n;\n\n  \n};\n\n\n}\n\n\nCar\n.\nmySweetProp\n \n=\n \n42\n;\n\n\n\nconst\n \nf\n \n=\n \nnew\n \nCar\n(\nFord\n,\n \nFocus\n);\n\n\nconsole\n.\nlog\n(\nf\n.\ntoString\n());\n\n\nconst\n \nt\n \n=\n \nnew\n \nCar\n(\nToyota\n,\n \nCorola\n);\n\n\nconsole\n.\nlog\n(\nt\n.\ntoString\n());\n\n\n\n// Car.prototype is shared by all objects created by calling new Car(...)\n\n\n// That\ns right you can treat functions like objects!\n\n\n\nconsole\n.\nlog\n(\nf\n.\n__proto__\n \n===\n \nCar\n.\nprototype\n);\n \n// ??\n\n\n\n// Let\ns define property common to all cars:\n\n\nCar\n.\nprototype\n.\ncolor\n \n=\n \nblack\n;\n\n\n\nconsole\n.\nlog\n(\nf\n.\ncolor\n);\n \n// ??\n\n\n// getProperty \ncolor\n of f\n\n\n//     if it has it, return it\n\n\n//     else getProperty \ncolor\n of f.__proto__\n\n\nconsole\n.\nlog\n(\nt\n.\ncolor\n);\n \n// ??\n\n\n\n// Can override the default color that is defined on the prototype:\n\n\n\nt\n.\ncolor\n \n=\n \nred\n;\n\n\n\nconsole\n.\nlog\n(\nt\n.\ncolor\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\nf\n.\ncolor\n);\n \n// ??\n\n\n\n// We can define a method on the prototype:\n\n\n\nCar\n.\nprototype\n.\ntoColorString\n \n=\n \nfunction\n \n()\n \n{\n\n  \nreturn\n \n`\n${\nthis\n.\nmake\n}\n, \n${\nthis\n.\nmodel\n}\n, \n${\nthis\n.\ncolor\n}\n`\n;\n\n\n};\n\n\n\nconsole\n.\nlog\n(\nf\n.\ntoColorString\n());\n \n// ??\n\n\nconsole\n.\nlog\n(\nt\n.\ntoColorString\n());\n \n// ??\n\n\n\n\n\n\nMore recently, however, JavaScript adopted classes. You can think of them as\nbeing \nsyntactic sugar\n for the above:\n\n\nclass\n \nCar\n \n{\n\n  \nconstructor\n(\nmake\n,\n \nmodel\n)\n \n{\n\n    \nthis\n.\nmake\n \n=\n \nmake\n;\n\n    \nthis\n.\nmodel\n \n=\n \nmodel\n;\n\n  \n}\n\n  \ntoString\n()\n \n{\n\n    \nreturn\n \n`\n${\nthis\n.\nmake\n}\n@\n${\nthis\n.\nmodel\n}\n`\n;\n\n  \n}\n\n  \nstatic\n \nget\n \nmySweetProp\n()\n \n{\n\n    \nreturn\n \n42\n;\n\n  \n}\n\n\n}\n\n\n\nconst\n \nf\n \n=\n \nnew\n \nCar\n(\nFord\n,\n \nFocus\n);\n\n\nconsole\n.\nlog\n(\nf\n.\ntoString\n());\n\n\nconst\n \nt\n \n=\n \nnew\n \nCar\n(\nToyota\n,\n \nCorola\n);\n\n\nconsole\n.\nlog\n(\nt\n.\ntoString\n());\n\n\n\n// Car.prototype is shared by all objects created by calling new Car(...)\n\n\n// That\ns right you can treat functions like objects!\n\n\n\nconsole\n.\nlog\n(\nf\n.\n__proto__\n \n===\n \nCar\n.\nprototype\n);\n \n// ??\n\n\n\n// We can define property common to all cars as before:\n\n\nCar\n.\nprototype\n.\ncolor\n \n=\n \nblack\n;\n\n\n\nconsole\n.\nlog\n(\nf\n.\ncolor\n);\n \n// ??\n\n\n// getProperty \ncolor\n of f\n\n\n//     if it has it, return it\n\n\n//     else getProperty \ncolor\n of f.__proto__\n\n\nconsole\n.\nlog\n(\nt\n.\ncolor\n);\n \n// ??\n\n\n\n// Can override the default color that is defined on the prototype:\n\n\n\nt\n.\ncolor\n \n=\n \nred\n;\n\n\n\nconsole\n.\nlog\n(\nt\n.\ncolor\n);\n \n// ??\n\n\nconsole\n.\nlog\n(\nf\n.\ncolor\n);\n \n// ??\n\n\n\n// We can define a method on the prototype as before:\n\n\n\nCar\n.\nprototype\n.\ntoColorString\n \n=\n \nfunction\n \n()\n \n{\n\n  \nreturn\n \n`\n${\nthis\n.\nmake\n}\n, \n${\nthis\n.\nmodel\n}\n, \n${\nthis\n.\ncolor\n}\n`\n;\n\n\n};\n\n\n\nconsole\n.\nlog\n(\nf\n.\ntoColorString\n());\n \n// ??\n\n\nconsole\n.\nlog\n(\nt\n.\ntoColorString\n());\n \n// ??", 
            "title": "Week 1"
        }, 
        {
            "location": "/lectures/week1/#lecture-slides-and-code", 
            "text": "Introduction:  pdf ,  key  JavaScript in a Nutshell:  pdf ,  key", 
            "title": "Lecture slides and code"
        }, 
        {
            "location": "/lectures/week1/#recommended-reading", 
            "text": "If you have not worked with JavaScript before, take some time to familiarize\nyourself with the basics of the language, as most of the labs in this class\nwill be in JavaScript.  We recommend the  Mozilla Developer Network's JavaScript\nGuide , but\nthere are many other tutorials on the Internet.  Dave Herman's  Effective JavaScript  is very good\nreference that covers a lot of the JavaScript intricacies.  You will not need\nthis for the class, but if you end up writing JavaScript code in the outside\nworld, this book is must-read.", 
            "title": "Recommended reading"
        }, 
        {
            "location": "/lectures/week1/#additional-resourcesreading-for-the-curious", 
            "text": "Block\n  bindings \n  and the difference between  var ,  let , and  const .  Why a language like JavaScript took over the world? Not that uncommon, see\n   The Rise of \"Worse is\n  Better\" .  Closures \n  explained; see, especially the creating closures in a loop section.  Private properties in (modern) JavaScript ; we will revisit the idea of private properties (encapsulation) later in the course.  Short intro to memory management for\n  JavaScript .  ES6 In Depth  contains\n  more information on the more recent features introduced to JavaScript.  Arrow functions .  JavaScript No-No's .", 
            "title": "Additional resources/reading for the curious"
        }, 
        {
            "location": "/lectures/week1/#source-code-used-in-class", 
            "text": "Below you'll find the source files we used during lecture. You can run these\nwith  Node.js .", 
            "title": "Source code used in class"
        }, 
        {
            "location": "/lectures/week1/#scoping", 
            "text": "Block scoping in modern JS:  function   hello ( x )   { \n   console . log ( `A: x =  ${ x } ` );   // 42 \n   { \n     let   x   =   45 ; \n     console . log ( `B: x =  ${ x } ` );   // 45 \n   } \n   { \n     console . log ( `C: x =  ${ x } ` );   // 42 \n   }  }  hello ( 42 );   Function (but not block) scoping for  var s:  function   hello ( x )   { \n   console . log ( `A: x =  ${ x } ` );   // ?? \n   { \n     var   x   =   45 ; \n     console . log ( `B: x =  ${ x } ` );   // ?? \n   } \n   { \n     console . log ( `C: x =  ${ x } ` );   // ?? \n   }  }  hello ( 42 );   Mimicking block scoping with functions:  function   hello ( x )   { \n   console . log ( `A: x =  ${ x } ` );   // ?? \n   ( function   ()   { \n     var   x   =   45 ; \n     console . log ( `B: x =  ${ x } ` );   // ?? \n   })(); \n   ( function   ()   { \n     console . log ( `C: x =  ${ x } ` );   // ?? \n   })();  }  hello ( 42 );   Now, with arrow functions:  function   hello ( x )   { \n   console . log ( `A: x =  ${ x } ` );   // ?? \n   ( function   ()   { \n     var   x   =   45 ; \n     console . log ( `B: x =  ${ x } ` );   // ?? \n   })(); \n   (()   =   { \n     console . log ( `C: x =  ${ x } ` );   // ?? \n   })();  }  hello ( 42 );", 
            "title": "Scoping"
        }, 
        {
            "location": "/lectures/week1/#performance", 
            "text": "Without high-order functions, we'd perform reads and write synchronously:  const   fs   =   require ( fs );  const   r1   =   fs . readFileSync ( ./perf-sync.js ,   utf8 );   // blocks until read is done  processFile ( perf-sync.js ,   r1 );   // blocks until processing (write) is done  const   r2   =   fs . readFileSync ( ./perf-async.js ,   utf8 );   // etc.  processFile ( perf-async.js ,   r2 );  // note that you can declare a function after the point it s used. Hoisting  // essentially moves it to the top.  function   processFile ( fname ,   str )   { \n   fs . writeFileSync ( `/tmp/ ${ fname } ` ,   str ); \n   console . log ( `DONE writing /tmp/ ${ fname } ` );  }   Passing (callback) functions as arguments allows the runtime system to call our function whenever it's ready. This allows it to perform IO concurrently and more efficiently:  const   fs   =   require ( fs );  fs . readFile ( ./perf-sync.js ,   utf8 ,   cb1 );   // returns immediately, cb1 is queued on the event loop and called later when actual file read is done  fs . readFile ( ./perf-async.js ,   utf8 ,   cb2 );   // returns immediately,     function   processFile ( fname ,   str )   { \n   fs . writeFileSync ( `/tmp/ ${ fname } ` ,   str ); \n   console . log ( `DONE writing /tmp/ ${ fname } ` );  }  function   cb1 ( err ,   str )   { \n   // line cb1.1 \n   processFile ( perf-sync.js ,   str );  }  function   cb2 ( err ,   str )   { \n   //line cb2.1 \n   processFile ( perf-async.js ,   str );  }  Can   cb2   execute   before   cb1 ?  A :   yes ,   B :   no   Once we can return functions we can also express our code more compactly too:  const   fs   =   require ( fs );  fs . readFile ( ./perf-sync.js ,   utf8 ,   processFile ( perf-sync.js ));  fs . readFile ( ./perf-async.js ,   utf8 ,   processFile ( perf-async.js ));  function   processFile ( fname )   { \n   return   ( err ,   str )   =   { \n     fs . writeFileSync ( `/tmp/ ${ fname } ` ,   str ); \n     console . log ( `DONE writing /tmp/ ${ fname } ` ); \n   };  }   And, slightly cleaner:  const   fs   =   require ( fs );  readAndProcessFile ( perf-sync.js );  readAndProcessFile ( perf-async.js );  function   readAndProcessFile ( name )   { \n   return   fs . readFile ( `./ ${ name } ` ,   utf8 ,   processFile ( name ));  }  function   processFile ( fname )   { \n   return   ( err ,   str )   =   { \n     fs . writeFileSync ( `/tmp/ ${ fname } ` ,   str ); \n     console . log ( `DONE writing /tmp/ ${ fname } ` ); \n   };  }", 
            "title": "Performance"
        }, 
        {
            "location": "/lectures/week1/#expressiveness", 
            "text": "High-order functions enables expressiveness:  const   list   =   [ 1 ,   2 ,   3 ,   4 ];  console . log ( filter ( list ,   function   ( el )   {  \n   return   el     2 ;  }));   // ??  console . log ( map ( list ,   el   =   {  \n   return   el   +   42 ;  }));   // ??  function   filter ( list ,   pred )   { \n   const   dup   =   []; \n   for   ( let   i   =   0 ;   i     list . length ;   i ++ )   { \n     if   ( pred ( list [ i ]))   { \n       dup . push ( list [ i ]); \n     } \n   } \n   return   dup ;  }  function   map ( list ,   f )   { \n   const   dup   =   []; \n   for   ( let   i   =   list . length - 1 ;   i   =   0 ;   i -- )   { \n     dup . unshift ( f ( list [ i ])); \n   } \n   return   dup ;  }   It also can enable more efficient code:  const   list   =   [ 1 ,   2 ,   3 ,   4 ];  const   add42   =   ( el )   =   { \n   return   el   +   42 ;  };  function   mul1337   ( el )   { \n   return   el   *   1337 ;  }  console . log ( map ( map ( list ,   add42 ),   mul1337 ));  console . log ( map ( list ,   compose ( mul1337 ,   add42 )));  function   compose   ( f ,   g )   { \n   return   ( x )   =   {  \n     return   f ( g ( x )); \n   }  }  function   map ( list ,   f )   { \n   const   dup   =   []; \n   for   ( let   i   =   list . length - 1 ;   i   =   0 ;   i -- )   { \n     dup . unshift ( f ( list [ i ])); \n   } \n   return   dup ;  }", 
            "title": "Expressiveness"
        }, 
        {
            "location": "/lectures/week1/#abstraction", 
            "text": "We can also use functions to implement module systems.  Consider a simple module in Node.js:  const   secret   =   cse130 is fun! ;   // scoped to this function, hidden to outside world  exports . myVar   =   42 ;  exports . myFunc   =   function   ( x )   { \n   if   ( x   ===   secret )   { \n     console . log ( yes! ); \n   }   else   { \n     console . log ( guess again! ); \n   }  };   This module can be loaded with  require , which is (very) roughly implemented\nas follows:  // using node s requie:  { \n   const   mod   =   require ( ./module-node.js ); \n\n   console . log ( mod . myVar );   // ?? \n   mod . myFunc ( what? );   // ?? \n   mod . myFunc ( cse130 is fun! );   // ??  }  // using our fake require:  { \n   const   mod   =   requireMyModule (); \n\n   console . log ( mod . myVar );   // ?? \n   mod . myFunc ( what? );   // ?? \n   mod . myFunc ( cse130 is fun! );   // ??  }  function   myModule ( exports )   { \n   // same code as module-node.js: \n   const   secret   =   cse130 is fun! ;   // scoped to this function, hidden to outside world \n   exports . myVar   =   42 ; \n   exports . myFunc   =   function   ( x )   { \n     if   ( x   ===   secret )   { \n       console . log ( yes! ); \n     }   else   { \n       console . log ( guess again! ); \n     } \n   };  }  function   requireMyModule ()   { \n   // create new object that will be populated by the module \n   const   exports   =   {}; \n   myModule ( exports ); \n   return   exports ;  }", 
            "title": "Abstraction"
        }, 
        {
            "location": "/lectures/week1/#objects", 
            "text": "We'll be looking at objects later in the class. Objects can be expressed\nad-hoc, using object literal notation:  const   obj   =   { \n   x-w00t :   10 , \n   x :   1337 , \n   f :   function   ( y )   { \n     this . x ++ ; \n     return   this . x   +   y ; \n   }  };  console . log ( obj . x );   // ??  console . log ( obj . f ( 3 ));   // ??  console . log ( obj [ x ]);   // ??  console . log ( obj [ x-w00t ])   // ??   But we can (again) use functions to construct objects:  function   Car ( make ,   model )   { \n   this . make   =   make ; \n   this . model   =   model ; \n   this . toString   =   function   ()   { \n     return   ` ${ this . make } @ ${ this . model } ` ; \n   };  }  Car . mySweetProp   =   42 ;  const   f   =   new   Car ( Ford ,   Focus );  console . log ( f . toString ());  const   t   =   new   Car ( Toyota ,   Corola );  console . log ( t . toString ());  // Car.prototype is shared by all objects created by calling new Car(...)  // That s right you can treat functions like objects!  console . log ( f . __proto__   ===   Car . prototype );   // ??  // Let s define property common to all cars:  Car . prototype . color   =   black ;  console . log ( f . color );   // ??  // getProperty  color  of f  //     if it has it, return it  //     else getProperty  color  of f.__proto__  console . log ( t . color );   // ??  // Can override the default color that is defined on the prototype:  t . color   =   red ;  console . log ( t . color );   // ??  console . log ( f . color );   // ??  // We can define a method on the prototype:  Car . prototype . toColorString   =   function   ()   { \n   return   ` ${ this . make } ,  ${ this . model } ,  ${ this . color } ` ;  };  console . log ( f . toColorString ());   // ??  console . log ( t . toColorString ());   // ??   More recently, however, JavaScript adopted classes. You can think of them as\nbeing  syntactic sugar  for the above:  class   Car   { \n   constructor ( make ,   model )   { \n     this . make   =   make ; \n     this . model   =   model ; \n   } \n   toString ()   { \n     return   ` ${ this . make } @ ${ this . model } ` ; \n   } \n   static   get   mySweetProp ()   { \n     return   42 ; \n   }  }  const   f   =   new   Car ( Ford ,   Focus );  console . log ( f . toString ());  const   t   =   new   Car ( Toyota ,   Corola );  console . log ( t . toString ());  // Car.prototype is shared by all objects created by calling new Car(...)  // That s right you can treat functions like objects!  console . log ( f . __proto__   ===   Car . prototype );   // ??  // We can define property common to all cars as before:  Car . prototype . color   =   black ;  console . log ( f . color );   // ??  // getProperty  color  of f  //     if it has it, return it  //     else getProperty  color  of f.__proto__  console . log ( t . color );   // ??  // Can override the default color that is defined on the prototype:  t . color   =   red ;  console . log ( t . color );   // ??  console . log ( f . color );   // ??  // We can define a method on the prototype as before:  Car . prototype . toColorString   =   function   ()   { \n   return   ` ${ this . make } ,  ${ this . model } ,  ${ this . color } ` ;  };  console . log ( f . toColorString ());   // ??  console . log ( t . toColorString ());   // ??", 
            "title": "Objects"
        }, 
        {
            "location": "/notes/js_nono/", 
            "text": "Below are code snippets that illustrate some of the flexible features of\nJavaScript and how they can introduce unexpected/unintuitive behavior. There\nare many more; see Appendix B of Crockford's \nJavaScript: The Good Parts\n.\nPlease note that there are useful, positive sides of most of these; every\nlanguage design/implementation decision is a trade-off.\n\n\nAutomatic semicolon insertion\n\n\nfunction\n \nf\n()\n \n{\n\n     \nreturn\n \n3\n;\n\n\n}\n\n\nfunction\n \ng\n()\n \n{\n\n     \nreturn\n\n       \n3\n;\n\n\n}\n\n\nconsole\n.\nlog\n(\nf\n());\n \n// ??\n\n\nconsole\n.\nlog\n(\ng\n());\n \n// ??\n\n\n\n\n\n\nEval\n\n\nJavaScript's \neval\n function can be used to load and execute new code at\nruntime. This is generally considered a bad/dangerous idea, but nevertheless\nuseful in some cases. Beyond security implications (mostly a concern in the\nbrowser since \neval\n can easily be leveraged to carry out \nXSS\nattacks\n), however the\nbehavior of \neval\n differs when you call it directly or indirectly. This\ndifference was introduced in the name of performance (arguably okay since you\nshould not be using \neval\n very much, but still not great.)\n\n\nglobal\n.\nx\n \n=\n \n33\n;\n\n\n{\n\n  \nconst\n \nx\n \n=\n \n44\n;\n\n  \nconst\n \nev\n \n=\n \neval\n;\n\n  \nconsole\n.\nlog\n(\neval\n(\nx\n));\n \n// ??\n\n  \nconsole\n.\nlog\n(\nev\n(\nx\n));\n \n// ??\n\n\n}\n\n\n\n\n\n\nImplicit casting\n\n\nSee the sarcastic \nWAT\n video.\n\n\nMonkeypatching\n\n\nBecause JavaScript lets you modify arbitrary objects and their prototypes,\nrunning untrusted code safely is extremely difficult to do. (If you're\ninterested in this, come talk to me; this is some of my research).\nSee some examples\n\nhere\n on global\nobject poisoning. Here is the simplest:\n\n\n// suppose add was exposed by a third-party library\n\n\nfunction\n \nadd\n(\nx\n,\n \ny\n)\n \n{\n\n  \n// Poison the Object prototype by redefining toString,\n\n  \n// which is called when objects are implicitly casted to\n\n  \n// strings. The modified function modifies the object (this), by\n\n  \n// setting name to \nmud\n;\n\n  \nObject\n.\nprototype\n.\ntoString\n \n=\n \nfunction\n \n()\n \n{\n\n    \nvar\n \nname\n \n=\n \nthis\n.\nname\n \n;\n\n    \nthis\n.\nname\n \n=\n \nmud\n;\n\n    \nreturn\n \nHA \n \n+\n \nname\n \n+\n \n.  IM STEALIN UR CODEZ!\n;\n\n  \n};\n\n  \nreturn\n \nx\n \n+\n \ny\n;\n\n\n}\n\n\n\nvar\n \no\n \n=\n \n{\n \nname\n:\n \nBingo\n \n};\n\n\nconsole\n.\nlog\n(\nadd\n(\n3\n,\n4\n));\n \n// calling add poisoned Object.prototype\n\n\nconsole\n.\nlog\n(\n \n+\n \no\n);\n\n\nconsole\n.\nlog\n(\nYour name is now \n \n+\n \no\n.\nname\n);", 
            "title": "JavaScript No No's"
        }, 
        {
            "location": "/notes/js_nono/#automatic-semicolon-insertion", 
            "text": "function   f ()   { \n      return   3 ;  }  function   g ()   { \n      return \n        3 ;  }  console . log ( f ());   // ??  console . log ( g ());   // ??", 
            "title": "Automatic semicolon insertion"
        }, 
        {
            "location": "/notes/js_nono/#eval", 
            "text": "JavaScript's  eval  function can be used to load and execute new code at\nruntime. This is generally considered a bad/dangerous idea, but nevertheless\nuseful in some cases. Beyond security implications (mostly a concern in the\nbrowser since  eval  can easily be leveraged to carry out  XSS\nattacks ), however the\nbehavior of  eval  differs when you call it directly or indirectly. This\ndifference was introduced in the name of performance (arguably okay since you\nshould not be using  eval  very much, but still not great.)  global . x   =   33 ;  { \n   const   x   =   44 ; \n   const   ev   =   eval ; \n   console . log ( eval ( x ));   // ?? \n   console . log ( ev ( x ));   // ??  }", 
            "title": "Eval"
        }, 
        {
            "location": "/notes/js_nono/#implicit-casting", 
            "text": "See the sarcastic  WAT  video.", 
            "title": "Implicit casting"
        }, 
        {
            "location": "/notes/js_nono/#monkeypatching", 
            "text": "Because JavaScript lets you modify arbitrary objects and their prototypes,\nrunning untrusted code safely is extremely difficult to do. (If you're\ninterested in this, come talk to me; this is some of my research).\nSee some examples here  on global\nobject poisoning. Here is the simplest:  // suppose add was exposed by a third-party library  function   add ( x ,   y )   { \n   // Poison the Object prototype by redefining toString, \n   // which is called when objects are implicitly casted to \n   // strings. The modified function modifies the object (this), by \n   // setting name to  mud ; \n   Object . prototype . toString   =   function   ()   { \n     var   name   =   this . name   ; \n     this . name   =   mud ; \n     return   HA    +   name   +   .  IM STEALIN UR CODEZ! ; \n   }; \n   return   x   +   y ;  }  var   o   =   {   name :   Bingo   };  console . log ( add ( 3 , 4 ));   // calling add poisoned Object.prototype  console . log (   +   o );  console . log ( Your name is now    +   o . name );", 
            "title": "Monkeypatching"
        }
    ]
}